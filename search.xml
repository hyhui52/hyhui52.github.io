<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis</title>
      <link href="/2022/01/20/redis/"/>
      <url>/2022/01/20/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><table><thead><tr><th align="center">数据类型</th><th align="center">可以存储的值</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center">字符串、整数或者浮点数</td><td align="center">对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt; 对整数和浮点数执行自增或者自减操作</td></tr><tr><td align="center">LIST</td><td align="center">列表</td><td align="center">从两端压入或者弹出元素 &lt;/br&gt; 对单个或者多个元素进行修剪，&lt;/br&gt; 只保留一个范围内的元素</td></tr><tr><td align="center">SET</td><td align="center">无序集合</td><td align="center">添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素</td></tr><tr><td align="center">HASH</td><td align="center">包含键值对的无序散列表</td><td align="center">添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在</td></tr><tr><td align="center">ZSET</td><td align="center">有序集合</td><td align="center">添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p></blockquote><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" width="400"> </div><br><pre class=" language-html"><code class="language-html">> set hello worldOK> get hello"world"> del hello(integer) 1> get hello(nil)</code></pre><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" width="400"> </div><br><pre class=" language-html"><code class="language-html">> rpush list-key item(integer) 1> rpush list-key item2(integer) 2> rpush list-key item(integer) 3> lrange list-key 0 -11) "item"2) "item2"3) "item"> lindex list-key 1"item2"> lpop list-key"item"> lrange list-key 0 -11) "item2"2) "item"</code></pre><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" width="400"> </div><br><pre class=" language-html"><code class="language-html">> sadd set-key item(integer) 1> sadd set-key item2(integer) 1> sadd set-key item3(integer) 1> sadd set-key item(integer) 0> smembers set-key1) "item"2) "item2"3) "item3"> sismember set-key item4(integer) 0> sismember set-key item(integer) 1> srem set-key item2(integer) 1> srem set-key item2(integer) 0> smembers set-key1) "item"2) "item3"</code></pre><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" width="400"> </div><br><pre class=" language-html"><code class="language-html">> hset hash-key sub-key1 value1(integer) 1> hset hash-key sub-key2 value2(integer) 1> hset hash-key sub-key1 value1(integer) 0> hgetall hash-key1) "sub-key1"2) "value1"3) "sub-key2"4) "value2"> hdel hash-key sub-key2(integer) 1> hdel hash-key sub-key2(integer) 0> hget hash-key sub-key1"value1"> hgetall hash-key1) "sub-key1"2) "value1"</code></pre><h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" width="400"> </div><br><pre class=" language-html"><code class="language-html">> zadd zset-key 728 member1(integer) 1> zadd zset-key 982 member0(integer) 1> zadd zset-key 982 member0(integer) 0> zrange zset-key 0 -1 withscores1) "member1"2) "728"3) "member0"4) "982"> zrangebyscore zset-key 0 800 withscores1) "member1"2) "728"> zrem zset-key member1(integer) 1> zrem zset-key member1(integer) 0> zrange zset-key 0 -1 withscores1) "member0"2) "982"</code></pre><h2 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht <span class="token punctuation">{</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span> dictht<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_t u64<span class="token punctuation">;</span>        int64_t s64<span class="token punctuation">;</span>        <span class="token keyword">double</span> d<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span></code></pre><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* rehashing not in progress if rehashidx == -1 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* number of iterators currently running */</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span></code></pre><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */</span><span class="token keyword">int</span> <span class="token function">dictRehash</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> empty_visits <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Max number of empty buckets to visit. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dictIsRehashing</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">&amp;&amp;</span> d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dictEntry <span class="token operator">*</span>de<span class="token punctuation">,</span> <span class="token operator">*</span>nextde<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Note that rehashidx can't overflow as we are sure there are more         * elements because ht[0].used != 0 */</span>        <span class="token function">assert</span><span class="token punctuation">(</span>d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> d<span class="token operator">-></span>rehashidx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-></span>rehashidx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            d<span class="token operator">-></span>rehashidx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>empty_visits <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        de <span class="token operator">=</span> d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-></span>rehashidx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Move all the keys in this bucket from the old to the new hash HT */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{</span>            uint64_t h<span class="token punctuation">;</span>            nextde <span class="token operator">=</span> de<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* Get the index in the new hash table */</span>            h <span class="token operator">=</span> <span class="token function">dictHashKey</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> de<span class="token operator">-></span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>            de<span class="token operator">-></span>next <span class="token operator">=</span> d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>            d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> de<span class="token punctuation">;</span>            d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">--</span><span class="token punctuation">;</span>            d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">++</span><span class="token punctuation">;</span>            de <span class="token operator">=</span> nextde<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-></span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        d<span class="token operator">-></span>rehashidx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* Check if we already rehashed the whole table... */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">zfree</span><span class="token punctuation">(</span>d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">_dictReset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token operator">-></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token operator">-></span>rehashidx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* More to rehash... */</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" width="600px"> </div><br><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" width="600px"> </div><br><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h2 id="五、Redis-与-Memcached"><a href="#五、Redis-与-Memcached" class="headerlink" title="五、Redis 与 Memcached"></a>五、Redis 与 Memcached</h2><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式的支持。</p><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p></li><li><p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p></li></ul><h2 id="六、键的过期时间"><a href="#六、键的过期时间" class="headerlink" title="六、键的过期时间"></a>六、键的过期时间</h2><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h2 id="七、数据淘汰策略"><a href="#七、数据淘汰策略" class="headerlink" title="七、数据淘汰策略"></a>七、数据淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th align="center">策略</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">volatile-lru</td><td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">volatile-ttl</td><td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td align="center">volatile-random</td><td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td align="center">allkeys-lru</td><td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">allkeys-random</td><td align="center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td align="center">noeviction</td><td align="center">禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h2 id="八、持久化"><a href="#八、持久化" class="headerlink" title="八、持久化"></a>八、持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th align="center">选项</th><th align="center">同步频率</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">每个写命令都同步</td></tr><tr><td align="center">everysec</td><td align="center">每秒同步一次</td></tr><tr><td align="center">no</td><td align="center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h2 id="九、事务"><a href="#九、事务" class="headerlink" title="九、事务"></a>九、事务</h2><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h2 id="十、事件"><a href="#十、事件" class="headerlink" title="十、事件"></a>十、事件</h2><p>Redis 服务器是一个事件驱动程序。</p><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" width=""> </div><br><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 获取到达时间离当前时间最接近的时间事件</span>    time_event <span class="token operator">=</span> aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算最接近的时间事件距离到达还有多少毫秒</span>    remaind_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span>    <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        remaind_ms <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 根据 remaind_ms 的值，创建 timeval</span>    timeval <span class="token operator">=</span> create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span>    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 处理所有已产生的文件事件</span>    procesFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 处理所有已到达的时间事件</span>    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 初始化服务器</span>    init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 一直处理事件，直到服务器关闭为止</span>    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 服务器关闭，执行清理操作</span>    clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>从事件处理的角度来看，服务器运行流程如下：</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" width="350"> </div><br><h2 id="十一、复制"><a href="#十一、复制" class="headerlink" title="十一、复制"></a>十一、复制</h2><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol><li><p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p></li><li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p></li><li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p></li></ol><h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" width="600"> </div><br><h2 id="十二、Sentinel"><a href="#十二、Sentinel" class="headerlink" title="十二、Sentinel"></a>十二、Sentinel</h2><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h2 id="十三、分片"><a href="#十三、分片" class="headerlink" title="十三、分片"></a>十三、分片</h2><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h2 id="十四、一个简单的论坛系统分析"><a href="#十四、一个简单的论坛系统分析" class="headerlink" title="十四、一个简单的论坛系统分析"></a>十四、一个简单的论坛系统分析</h2><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h3 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h3><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png" width="400"> </div><br><h3 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h3><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png" width="400"> </div><br><h3 id="对文章进行排序"><a href="#对文章进行排序" class="headerlink" title="对文章进行排序"></a>对文章进行排序</h3><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" width="800"> </div><br>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2021/12/23/ji-suan-ji-wang-luo/"/>
      <url>/2021/12/23/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>1 域名系统</strong></p><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p><p><strong>HTTP协议</strong></p><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2 传输层"></a>2 传输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><h4 id="运输层主要使用以下两种协议"><a href="#运输层主要使用以下两种协议" class="headerlink" title="运输层主要使用以下两种协议"></a>运输层主要使用以下两种协议</h4><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h4><ol><li>UPD是无连接的；</li><li>UDP使用最大努力交互，即不保证可靠交付，因此主机不需要维复杂的链接状态（这里有许多参数）；</li><li>UDP是面向报文的；</li><li>UDP没有阻塞控制，因此网络出现阻塞不会使源主机的发送率降低（对实时应用很有用，如 直播，实时视频会议等）；</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP的首部开销小，只有8个字节，比TCP的20个字节首部要短</li></ol><h4 id="TCP-的主要特点"><a href="#TCP-的主要特点" class="headerlink" title="TCP 的主要特点"></a>TCP 的主要特点</h4><ol><li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP提供可靠的传输服务。通过TCP链接的方式传送数据，无差错、不丢失、不重复、按序到达</li><li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ol><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3 网络层"></a>3 网络层</h3><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4 数据链路层"></a>4 数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h3 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5 物理层"></a>5 物理层</h3><p>在物理层上所传送的数据单位是比特。<br><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC83LzI5LzE2NGU1MjkzMDlmMGZhMzM?x-oss-process=image/format,png" alt="七层体系结构图"></p><h2 id="二-TCP-三次握手和四次挥手-面试常客"><a href="#二-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="二 TCP 三次握手和四次挥手(面试常客)"></a>二 TCP 三次握手和四次挥手(面试常客)</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><p><strong>漫画图解：</strong></p><p>图片来源：《图解HTTP》<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzgvMTYzM2UxMjczOTY1NDFmMQ?x-oss-process=image/format,png" alt="TCP三次握手"></p><p><strong>简单示意图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzgvMTYzM2UxNDIzM2Q5NTk3Mg?x-oss-process=image/format,png" alt="TCP三次握手"></p><p> <strong>为什么要三次握手</strong></p><p>​        三次握手的目的是建立可靠的通信信道，说道通讯，简单来说数据的发送与接收，而<strong>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><ul><li>第一次握手：Client什么都不能确认；Server确认了对方发送正常</li><li>第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常， 对方发送接收正常</li><li>第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常，对方发送接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</li></ul><p><strong>为什么要传回SYN</strong></p><p>接收端传回发送端发送的SYN是为了告诉发送端， 我接收到的信息确实就是你所发送的信号了。</p><pre><code>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</code></pre><p><strong>传了SYN, 为啥还要传ACK</strong></p><p>双方通信无误必须是两者互相发送信息都无误。 传了SYN, 证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号俩进行验证。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzgvMTYzM2UxNjc2ZTJhYzBhMw?x-oss-process=image/format,png" alt="TCP四次挥手"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h2 id="三-TCP、UDP-协议的区别"><a href="#三-TCP、UDP-协议的区别" class="headerlink" title="三 TCP、UDP 协议的区别"></a>三 TCP、UDP 协议的区别</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC80LzE5LzE2MmRiNWU5N2U5YTllMDE?x-oss-process=image/format,png" alt="TCP、UDP协议的区别"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h2 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h2><ol><li>应用数据被分割成TCP认为最适合发送的数据块</li><li>TCP给发送方每个包进行编号，接收方根据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和</strong>： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制</strong>： 当网络阻塞时，减少数据传送。</li><li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发送一个分组数据就停车发送，等待接收方确认，在收到确认后再发下一个分组</li><li><strong>超时重传</strong>： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h3 id="4-1-ARQ协议"><a href="#4-1-ARQ协议" class="headerlink" title="4.1 ARQ协议"></a>4.1 ARQ协议</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时机制，在不可靠服务基础上实现可靠的信息传输。如果发送方在发送一段数据之后没有收到确认帧，他通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><p>优点： 简单</p><p>缺点： 信道利用率低，等待时间长</p><ol><li>无差错情况:</li></ol><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><ol start="2"><li>出现差错情况（超时重传）:</li></ol><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><ol start="3"><li>确认丢失和确认迟到</li></ol><ul><li>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li><li>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h3 id="4-2-滑动窗口和流量控制"><a href="#4-2-滑动窗口和流量控制" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p>TCP利用滑动串窗口实现流量控制。流量控制是为了控制发送发送速率,保证接收方来的及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的速率。将窗口字段设置为0，则发送方不能发送数据。</p><h3 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li>慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li>拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li>快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h2 id="八-HTTP长连接-短连接"><a href="#八-HTTP长连接-短连接" class="headerlink" title="八 HTTP长连接,短连接"></a>八 HTTP长连接,短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><pre><code>Connection:keep-alive</code></pre><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a></p><h3 id="4-2-滑动窗口和流量控制-1"><a href="#4-2-滑动窗口和流量控制-1" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="4-3-拥塞控制-1"><a href="#4-3-拥塞控制-1" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li>慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li>拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li>快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h2 id="五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="五 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)"></a>五 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h2><p>百度好像最喜欢问这个问题。</p><blockquote><p>打开一个网页，整个过程会使用哪些协议</p></blockquote><p>图解（图片来源：《图解HTTP》）：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></li></ul><h2 id="六-状态码"><a href="#六-状态码" class="headerlink" title="六 状态码"></a>六 状态码</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p><h2 id="七-各种协议与HTTP协议之间的关系"><a href="#七-各种协议与HTTP协议之间的关系" class="headerlink" title="七 各种协议与HTTP协议之间的关系"></a>七 各种协议与HTTP协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p><p>图片来源：《图解HTTP》</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系"></p><h2 id="八-HTTP长连接-短连接-1"><a href="#八-HTTP长连接-短连接-1" class="headerlink" title="八 HTTP长连接,短连接"></a>八 HTTP长连接,短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><pre><code>Connection:keep-alive</code></pre><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a></p><h2 id="九-HTTP是不保存状态的协议-如何保存用户状态"><a href="#九-HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="九 HTTP是不保存状态的协议,如何保存用户状态?"></a>九 HTTP是不保存状态的协议,如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p>Cookie 被禁用怎么办?</p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png" alt="HTTP是无状态协议"></p><h2 id="十-Cookie的作用是什么-和Session有什么区别？"><a href="#十-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="十 Cookie的作用是什么?和Session有什么区别？"></a>十 Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="十一-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#十一-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="十一 HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><blockquote><p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A</a>? 的一些内容。</p></blockquote><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li>错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h2 id="十二-URI和URL的区别是什么"><a href="#十二-URI和URL的区别是什么" class="headerlink" title="十二 URI和URL的区别是什么?"></a>十二 URI和URL的区别是什么?</h2><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="十三-HTTP-和-HTTPS-的区别？"><a href="#十三-HTTP-和-HTTPS-的区别？" class="headerlink" title="十三 HTTP 和 HTTPS 的区别？"></a>十三 HTTP 和 HTTPS 的区别？</h2><ol><li>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li><li>安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。<ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语法</title>
      <link href="/2021/12/15/sql-yu-fa/"/>
      <url>/2021/12/15/sql-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">## 注释</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span><span class="token comment" spellcheck="true">/* 注释1   注释2 */</span></code></pre><p>数据库创建与使用：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span><span class="token keyword">USE</span> test<span class="token punctuation">;</span></code></pre><h2 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable <span class="token punctuation">(</span>  <span class="token comment" spellcheck="true"># int 类型，不为空，自增</span>  id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># int 类型，不可为空，默认值为 1，不为空</span>  col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 变长字符串类型，最长为 45 个字符，可以为空</span>  col2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 日期类型，可为空</span>  col3 <span class="token keyword">DATE</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 设置主键为 id</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h2><p>添加列</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable<span class="token keyword">ADD</span> col CHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>删除列</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> col<span class="token punctuation">;</span></code></pre><p>删除表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">;</span></code></pre><h2 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h2><p>普通插入</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>插入检索出来的数据</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable1<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token keyword">FROM</span> mytable2<span class="token punctuation">;</span></code></pre><p>将一个表的内容插入到一个新表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> newtable <span class="token keyword">AS</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre><h2 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> mytable<span class="token keyword">SET</span> col <span class="token operator">=</span> val<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><h2 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p><strong>TRUNCATE TABLE</strong>   可以清空表，也就是删除所有行。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">;</span></code></pre><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h2 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h2><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> col1<span class="token punctuation">,</span> col2<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre><h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre><p>返回第 3 ~ 5 行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><h2 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h2><ul><li>  <strong>ASC</strong>  ：升序（默认）</li><li>  <strong>DESC</strong>  ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1 <span class="token keyword">DESC</span><span class="token punctuation">,</span> col2 <span class="token keyword">ASC</span><span class="token punctuation">;</span></code></pre><h2 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span></code></pre><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;&gt; !=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;= !&gt;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;= !&lt;</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在两个值之间</td></tr><tr><td align="center">IS NULL</td><td align="center">为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong>   用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>   操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>   操作符用于否定一个条件。</p><h2 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h2><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><p>  <strong>%</strong>   匹配 &gt;=0 个任意字符；</p></li><li><p>  <strong>_</strong>   匹配 ==1 个任意字符；</p></li><li><p>  <strong>[ ]</strong>   可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p></li></ul><p>使用 Like 来进行通配符匹配。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">LIKE</span> <span class="token string">'[^AB]%'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 不以 A 和 B 开头的任意文本</span></code></pre><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h2 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h2><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用   <strong>AS</strong>   来取别名，否则输出的时候字段名为计算表达式。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col1 <span class="token operator">*</span> col2 <span class="token keyword">AS</span> alias<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre><p><strong>CONCAT()</strong>   用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span>TRIM<span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> TRIM<span class="token punctuation">(</span>col2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> concat_col<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre><h2 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h2><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">AVG()</td><td align="center">返回某列的平均值</td></tr><tr><td align="center">COUNT()</td><td align="center">返回某列的行数</td></tr><tr><td align="center">MAX()</td><td align="center">返回某列的最大值</td></tr><tr><td align="center">MIN()</td><td align="center">返回某列的最小值</td></tr><tr><td align="center">SUM()</td><td align="center">返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以汇总不同的值。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_col<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">LEFT()</td><td align="center">左边的字符</td></tr><tr><td align="center">RIGHT()</td><td align="center">右边的字符</td></tr><tr><td align="center">LOWER()</td><td align="center">转换为小写字符</td></tr><tr><td align="center">UPPER()</td><td align="center">转换为大写字符</td></tr><tr><td align="center">LTRIM()</td><td align="center">去除左边的空格</td></tr><tr><td align="center">RTRIM()</td><td align="center">去除右边的空格</td></tr><tr><td align="center">LENGTH()</td><td align="center">长度</td></tr><tr><td align="center">SOUNDEX()</td><td align="center">转换为语音值</td></tr></tbody></table><p>其中，  <strong>SOUNDEX()</strong>   可以将一个字符串转换为描述其语音表示的字母数字模式。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> SOUNDEX<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token operator">=</span> SOUNDEX<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span></code></pre><h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:&lt;zero-width space&gt;MM:SS</li></ul><table><thead><tr><th align="center">函 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">ADDDATE()</td><td align="center">增加一个日期（天、周等）</td></tr><tr><td align="center">ADDTIME()</td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">返回当前时间</td></tr><tr><td align="center">DATE()</td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center">DATEDIFF()</td><td align="center">计算两个日期之差</td></tr><tr><td align="center">DATE_ADD()</td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center">DATE_FORMAT()</td><td align="center">返回一个格式化的日期或时间串</td></tr><tr><td align="center">DAY()</td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center">DAYOFWEEK()</td><td align="center">对于一个日期，返回对应的星期几</td></tr><tr><td align="center">HOUR()</td><td align="center">返回一个时间的小时部分</td></tr><tr><td align="center">MINUTE()</td><td align="center">返回一个时间的分钟部分</td></tr><tr><td align="center">MONTH()</td><td align="center">返回一个日期的月份部分</td></tr><tr><td align="center">NOW()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">SECOND()</td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center">TIME()</td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center">YEAR()</td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>2018-4-14 20:25:11</code></pre><h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">SIN()</td><td align="center">正弦</td></tr><tr><td align="center">COS()</td><td align="center">余弦</td></tr><tr><td align="center">TAN()</td><td align="center">正切</td></tr><tr><td align="center">ABS()</td><td align="center">绝对值</td></tr><tr><td align="center">SQRT()</td><td align="center">平方根</td></tr><tr><td align="center">MOD()</td><td align="center">余数</td></tr><tr><td align="center">EXP()</td><td align="center">指数</td></tr><tr><td align="center">PI()</td><td align="center">圆周率</td></tr><tr><td align="center">RAND()</td><td align="center">随机数</td></tr></tbody></table><h2 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h2><p>把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num<span class="token keyword">FROM</span> mytable<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token punctuation">;</span></code></pre><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num<span class="token keyword">FROM</span> mytable<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> num<span class="token punctuation">;</span></code></pre><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">></span> <span class="token number">2</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token keyword">HAVING</span> num <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h2 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h2><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable1<span class="token keyword">WHERE</span> col1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> col2               <span class="token keyword">FROM</span> mytable2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>                   <span class="token keyword">FROM</span> Orders                   <span class="token keyword">WHERE</span> Orders<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span>                   <span class="token keyword">AS</span> orders_num<span class="token keyword">FROM</span> Customers<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span></code></pre><h2 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> tableb <span class="token keyword">AS</span> B<span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span></code></pre><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A<span class="token punctuation">,</span> tableb <span class="token keyword">AS</span> B<span class="token keyword">WHERE</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span></code></pre><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> name<span class="token keyword">FROM</span> employee<span class="token keyword">WHERE</span> department <span class="token operator">=</span> <span class="token punctuation">(</span>      <span class="token keyword">SELECT</span> department      <span class="token keyword">FROM</span> employee      <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">"Jim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>自连接版本</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token number">e1</span><span class="token punctuation">.</span>name<span class="token keyword">FROM</span> employee <span class="token keyword">AS</span> <span class="token number">e1</span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> employee <span class="token keyword">AS</span> <span class="token number">e2</span><span class="token keyword">ON</span> <span class="token number">e1</span><span class="token punctuation">.</span>department <span class="token operator">=</span> <span class="token number">e2</span><span class="token punctuation">.</span>department      <span class="token operator">AND</span> <span class="token number">e2</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Jim"</span><span class="token punctuation">;</span></code></pre><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> tableb <span class="token keyword">AS</span> B<span class="token punctuation">;</span></code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> Customer<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>order_id<span class="token keyword">FROM</span> Customers <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Orders<span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span></code></pre><p>customers 表：</p><table><thead><tr><th align="center">cust_id</th><th align="center">cust_name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">b</td></tr><tr><td align="center">3</td><td align="center">c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th align="center">order_id</th><th align="center">cust_id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th align="center">cust_id</th><th align="center">cust_name</th><th align="center">order_id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">4</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">Null</td></tr></tbody></table><h2 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h2><p>使用   <strong>UNION</strong>   来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">UNION</span><span class="token keyword">SELECT</span> col<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre><h2 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> myview <span class="token keyword">AS</span><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span> <span class="token keyword">AS</span> concat_col<span class="token punctuation">,</span> col3<span class="token operator">*</span>col4 <span class="token keyword">AS</span> compute_col<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col5 <span class="token operator">=</span> val<span class="token punctuation">;</span></code></pre><h2 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> myprocedure<span class="token punctuation">(</span> <span class="token keyword">out</span> ret <span class="token keyword">int</span> <span class="token punctuation">)</span>    <span class="token keyword">begin</span>        <span class="token keyword">declare</span> y <span class="token keyword">int</span><span class="token punctuation">;</span>        <span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>col1<span class="token punctuation">)</span>        <span class="token keyword">from</span> mytable        <span class="token keyword">into</span> y<span class="token punctuation">;</span>        <span class="token keyword">select</span> y<span class="token operator">*</span>y <span class="token keyword">into</span> ret<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">call</span> myprocedure<span class="token punctuation">(</span><span class="token variable">@ret</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@ret</span><span class="token punctuation">;</span></code></pre><h2 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h2><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> myprocedure<span class="token punctuation">(</span><span class="token keyword">out</span> ret <span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token keyword">begin</span>        <span class="token keyword">declare</span> done <span class="token keyword">boolean</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">declare</span> mycursor <span class="token keyword">cursor</span> <span class="token keyword">for</span>        <span class="token keyword">select</span> col1 <span class="token keyword">from</span> mytable<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true"># 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span>        <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">handler</span> <span class="token keyword">for</span> sqlstate <span class="token string">'02000'</span> <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">open</span> mycursor<span class="token punctuation">;</span>        repeat            <span class="token keyword">fetch</span> mycursor <span class="token keyword">into</span> ret<span class="token punctuation">;</span>            <span class="token keyword">select</span> ret<span class="token punctuation">;</span>        until done <span class="token keyword">end</span> repeat<span class="token punctuation">;</span>        <span class="token keyword">close</span> mycursor<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token comment" spellcheck="true">//</span> <span class="token keyword">delimiter</span> <span class="token punctuation">;</span></code></pre><h2 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h2><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> mytrigger <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mytable<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>col <span class="token keyword">into</span> <span class="token variable">@result</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@result</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 获取结果</span></code></pre><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h2 id="二十一、事务管理"><a href="#二十一、事务管理" class="headerlink" title="二十一、事务管理"></a>二十一、事务管理</h2><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token comment" spellcheck="true">// ...</span><span class="token keyword">SAVEPOINT</span> delete1<span class="token comment" spellcheck="true">// ...</span><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> delete1<span class="token comment" spellcheck="true">// ...</span><span class="token keyword">COMMIT</span></code></pre><h2 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h2><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>col <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER SET</span> latin <span class="token keyword">COLLATE</span> latin1_general_ci <span class="token punctuation">)</span><span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER SET</span> hebrew <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span></code></pre><p>可以在排序、分组时指定校对：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col <span class="token keyword">COLLATE</span> latin1_general_ci<span class="token punctuation">;</span></code></pre><h2 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h2><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token keyword">user</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></code></pre><p><strong>创建账户</strong>  </p><p>新创建的账户没有任何权限。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> myuser IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'mypassword'</span><span class="token punctuation">;</span></code></pre><p><strong>修改账户名</strong>  </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> myuser <span class="token keyword">TO</span> newuser<span class="token punctuation">;</span></code></pre><p><strong>删除账户</strong>  </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> myuser<span class="token punctuation">;</span></code></pre><p><strong>查看权限</strong>  </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> myuser<span class="token punctuation">;</span></code></pre><p><strong>授予权限</strong>  </p><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mydatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> myuser<span class="token punctuation">;</span></code></pre><p><strong>删除权限</strong>  </p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mydatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> myuser<span class="token punctuation">;</span></code></pre><p><strong>更改密码</strong>  </p><p>必须使用 Password() 函数进行加密。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SET</span> PASSWROD <span class="token keyword">FOR</span> myuser <span class="token operator">=</span> Password<span class="token punctuation">(</span><span class="token string">'new_password'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2021/12/14/hashmap/"/>
      <url>/2021/12/14/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title=" HashMap"></a><center> HashMap</center></h1><h2 id="一-什么是哈希表"><a href="#一-什么是哈希表" class="headerlink" title="一.什么是哈希表"></a>一.什么是哈希表</h2><p>​        <strong>哈希表（hash table）</strong> 也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表。</p><p><strong>其他数据结构在新增，查找等基础操作执行性能与哈希表对比：</strong></p><ul><li><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</li><li><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</li><li><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</li><li><strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。</li></ul><p>数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p><strong>比如要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</strong></p><p>这个函数可以简单描述为：<strong>存储位置 = f(关键字)</strong> ，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如要在哈希表中执行插入操作：</p><p>插入过程如下图所示：</p><p><img src="http://cdn.xiongsihao.com/202003281554_785.png"></p><p><strong>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</strong></p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p><strong>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办</strong>？</p><p>也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫<strong>哈希碰撞</strong>。</p><p>前面提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。</p><p>那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了<strong>链地址法</strong>，也就是<strong>数组+链表</strong>的方式。</p><h1 id="二-HashMap基本使用"><a href="#二-HashMap基本使用" class="headerlink" title="二. HashMap基本使用"></a>二. HashMap基本使用</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">hashmapTest1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//put设值</span>        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"boy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"cat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回hashMap内key-value数量</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a:"</span> <span class="token operator">+</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//get取值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//containsKey查找hashMap是否包含指定key</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//containsValue查找hashMap是否包含指定value</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//remove移除hashMap中指定key的数据，没有指定key就返回null</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回hashMap所有key</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断hashMap是否为空</span>                <span class="token comment" spellcheck="true">//采用Iterator遍历HashMap</span>        Iterator it <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String key <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key:"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value:"</span> <span class="token operator">+</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//遍历HashMap的另一个方法</span>        Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> sets <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> sets<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="三-HashMap的实现原理"><a href="#三-HashMap的实现原理" class="headerlink" title="三. HashMap的实现原理"></a>三. HashMap的实现原理</h1><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> EMPTY_TABLE<span class="token punctuation">;</span></code></pre><p>Entry是HashMap中的一个静态内部类。代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储指向下一个Entry的引用，单链表结构</span>    <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span>    <span class="token comment" spellcheck="true">/**     * Creates new entry.     */</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>        next <span class="token operator">=</span> n<span class="token punctuation">;</span>        key <span class="token operator">=</span> k<span class="token punctuation">;</span>        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span> </code></pre><p>简单来说，<strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；</p><p>如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好。</strong></p><h2 id="3-1-HashMap的默认值"><a href="#3-1-HashMap的默认值" class="headerlink" title="3.1 HashMap的默认值"></a>3.1 HashMap的默认值</h2><p><img src="http://cdn.xiongsihao.com/202003281714_517.png"></p><ul><li><p><strong>DEFAULT_INITIAL_CAPACITY</strong>：</p><p>默认的初始容量，必须是2的倍数。默认16也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</p></li><li><p><strong>MAXIMUM_CAPACITY</strong>：哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</p></li><li><p><strong>DEFAULT_LOAD_FACTOR</strong>：默认的负载因子。因此初始情况下，当键值对的数量大于 <code>16 * 0.75 = 12</code> 时，就会触发扩容，扩容到32。</p></li><li><p><strong>TREEIFY_THRESHOLD</strong>：如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</p></li><li><p><strong>UNTREEIFY_THRESHOLD</strong>：在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</p></li><li><p><strong>MIN_TREEIFY_CAPACITY</strong>：在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</p></li></ul><p><strong>其中MAXIMUM_CAPACITY 为什么设置成1 &lt;&lt; 30？</strong></p><p>因为HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方。</p><p>而采用位运算&lt;&lt;来控制HashMap的大小，使用位运算同时还提高了Java的处理速度。 HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30。</p><h2 id="3-2-其他几个重要字段"><a href="#3-2-其他几个重要字段" class="headerlink" title="3.2 其他几个重要字段"></a>3.2 其他几个重要字段</h2><p>查看hashmap源码：</p><p><img src="http://cdn.xiongsihao.com/202003281654_329.png"></p><ul><li><p>transient int size：<strong>实际存储的key-value键值对的个数</strong></p></li><li><p>int threshold：</p><p><strong>阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold。</strong></p></li><li><p>final float loadFactor：</p><ul><li>负载因子，代表了table的填充度有多少，默认是0.75。</li><li>负载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。</li><li><strong>所以负载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</strong></li></ul></li><li><p>transient int modCount：</p><ul><li>HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时， 如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作）， <strong>需要抛出异常ConcurrentModificationException</strong></li></ul></li></ul><h1 id="四-JDK1-8中HashMap的性能优化"><a href="#四-JDK1-8中HashMap的性能优化" class="headerlink" title="四. JDK1.8中HashMap的性能优化"></a>四. JDK1.8中HashMap的性能优化</h1><h2 id="4-1-传统-HashMap的缺点"><a href="#4-1-传统-HashMap的缺点" class="headerlink" title="4.1 传统 HashMap的缺点"></a>4.1 传统 HashMap的缺点</h2><ul><li>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。</li><li>当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。</li><li>针对这种情况，JDK 1.8 中引入了红黑树（查找时间复杂度为 O(logn)）来优化这个问题，即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</li></ul><h2 id="4-2-桶的树形化-treeifyBin"><a href="#4-2-桶的树形化-treeifyBin" class="headerlink" title="4.2 桶的树形化 treeifyBin()"></a>4.2 桶的树形化 treeifyBin()</h2><p>在Java 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用红黑树来替换链表，从而提高速度。</p><p>这个替换的方法叫 treeifyBin() 即树形化。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将桶内所有的 链表节点 替换成 红黑树节点</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果哈希表中的元素个数超过了 树形化阈值，进行树形化</span>        <span class="token comment" spellcheck="true">// e 是哈希表中指定位置桶里的链表节点，从第一个开始</span>       TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hd <span class="token operator">=</span> null<span class="token punctuation">,</span> tl <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//红黑树的头、尾节点</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//新建一个树形节点，内容和当前链表节点 e 一致</span>            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                 hd <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//确定树头节点</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                   p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>             hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> p<span class="token punctuation">.</span>key<span class="token punctuation">,</span> p<span class="token punctuation">.</span>value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>上述操作做了这些事:</p><p>(1)根据哈希表中元素个数确定是扩容还是树形化</p><p>(2)如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p><p>(3)然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容</p><h2 id="4-3-HashMap的put方法"><a href="#4-3-HashMap的put方法" class="headerlink" title="4.3 HashMap的put方法"></a>4.3 HashMap的put方法</h2><h3 id="JDK1-7HashMap的put方法源码"><a href="#JDK1-7HashMap的put方法源码" class="headerlink" title="JDK1.7HashMap的put方法源码"></a><strong>JDK1.7HashMap的put方法源码</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果table为空，则根据size的阈值填充，即为空则初始化</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历当前索引的冲突链，找是否存在对应的key</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果存在对应的key， 则替换oldValue并返回oldValue</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//冲突链中不存在新写入的Entry的key，则直接add</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>其中：if (key == null)，则进入putForNullKey( )方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> V <span class="token function">putForNullKey</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>putForNullKey()方法的执行逻辑为：</p><ul><li>遍历table并判断其中是否已经存在一个entry的key==null。<ul><li>如果已经存在则返回旧值并用新值替换。</li><li>如果没有，则调用第三个方法：addEntry( )</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩容方法，原有基础上容量乘以2</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>addEntry()方法中看到首先根据<strong>threshold</strong>和<strong>table</strong>中你所给出的桶索引位置是否为null来判断是否需要扩展map。不是要说的重点。 接下来不管扩不扩容，第四个方法createEntry()才是真正意义上的插入方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>createEntry( )方法中可以看到，首先根据你给出的桶索引去到对应的entry e; 然后执行赋值：table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e)； 那么这句就是把新的已经携带了你要添加的key和value值的entry添加到map中。 这句的关键就是第五个方法也就是new Entry&lt;&gt;的构建了：</p><pre class=" language-java"><code class="language-java"><span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>        next <span class="token operator">=</span> n<span class="token punctuation">;</span>        key <span class="token operator">=</span> k<span class="token punctuation">;</span>        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>根据Entry的构造函数可以看出，把最后一个参数赋值给了next,而当前的k和value就是当前值。而n值就是原有的entry的完整值。 <strong>所以可以得出是添加到头部，而不是结尾处。</strong></p><h3 id="JDK1-8HashMap的put方法源码"><a href="#JDK1-8HashMap的put方法源码" class="headerlink" title="JDK1.8HashMap的put方法源码"></a>JDK1.8HashMap的put方法源码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对key的hashCode()做hash</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 步骤1：tab为空则创建</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 步骤2：计算index，并对null做处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤3：节点key存在，直接覆盖value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤4：判断该链为红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤5：该链为链表</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//链表长度大于8转换为红黑树进行处理</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// key已经存在直接覆盖value</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 步骤6：超过最大容量 就扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><p><strong>附：HashMap put方法逻辑图（JDK1.8）</strong></p><p><img src="http://cdn.xiongsihao.com/202003281858_958.png"></p><h2 id="4-4-红黑树中查找元素-getTreeNode"><a href="#4-4-红黑树中查找元素-getTreeNode" class="headerlink" title="4.4 红黑树中查找元素 getTreeNode()"></a>4.4 红黑树中查找元素 getTreeNode()</h2><p>HashMap 在 JDK 1.8 中新增的操作： 红黑树中查找元素 getTreeNode()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>(1)HashMap 的查找方法是 get(),它通过计算指定 key 的哈希值后，调用内部方法 getNode()；</li><li>(2)这个 getNode() 方法就是根据哈希表元素个数与哈希值求模（使用的公式是 (n - 1) &amp;hash）得到 key 所在的桶的头结点，如果头节点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。</li><li>(3)getTreeNode 方法使通过调用树形节点的 find()方法进行查找：</li></ul><pre class=" language-java"><code class="language-java"> <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><ul><li>(4)由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。</li><li>(5)这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回；不相等就从子树中递归查找。</li></ul><h2 id="4-5-HashMap扩容机制"><a href="#4-5-HashMap扩容机制" class="headerlink" title="4.5 HashMap扩容机制"></a>4.5 HashMap扩容机制</h2><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作。</p><h3 id="Java-7-中Hashmap扩容机制"><a href="#Java-7-中Hashmap扩容机制" class="headerlink" title="Java 7 中Hashmap扩容机制"></a>Java 7 中Hashmap扩容机制</h3><p>JAVA7扩容必须同时满足两个条件：</p><p><strong>(1)存放新值的时候当前已有元素的个数必须大于等于阈值</strong></p><p><strong>(2)存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</strong></p><p>因为扩容要同时满足上面这两个条件，所以存在下面这些情况：</p><ul><li>就是hashmap在存值的时候（默认大小为16，负载因子0.75，阈值12），可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。</li><li>当然也有可能存储更多值（超或16个值，最多可以存26个值）都还没有扩容。<ul><li>原因：前11个值全部hash碰撞，存到数组的同一个位置（虽然hash冲突，但是这时元素个数小于阈值12，并没有同时满足扩容的两个条件。所以不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，也没有同时满足扩容的两个条件，所以叶不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。</li></ul></li></ul><h3 id="Java-8-中Hashmap扩容机制"><a href="#Java-8-中Hashmap扩容机制" class="headerlink" title="Java 8 中Hashmap扩容机制"></a><strong>Java 8 中Hashmap扩容机制</strong></h3><p>Java8不再像Java7中那样需要同时满足两个条件。</p><p>Java8中扩容只需要满足一个条件：<strong>当前存放新值（注意不是替换已有元素位置时）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</strong></p><p>即hashmap默认大小为16，负载因子0.75，阈值12；在java8中，当存入第13个值时必定触发扩容。</p><p>　<strong>注：</strong></p><p>　　（1）扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（比如：put（“name”,”zhangsan”），而map里面原有数据&lt;”name”,”lisi”&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）</p><p>　　（2）扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</p><h2 id="4-6-底层结构"><a href="#4-6-底层结构" class="headerlink" title="4.6 底层结构"></a>4.6 底层结构</h2><ul><li>Java7中Hashmap底层采用的是Entry对数组，而每一个Entry对又向下延伸是一个链表，在链表上的每一个Entry对不仅存储着自己的key/value值，还存了前一个和后一个Entry对的地址。</li><li>Java8中的Hashmap底层结构有一定的变化，还是使用的数组，但是数组的对象以前是Entry对，现在换成了Node对象（可以理解是Entry对，结构一样，存储时也会存key/value键值对、前一个和后一个Node的地址），以前所有的Entry向下延伸都是链表，Java8变成链表和红黑树的组合，数据少量存入的时候优先还是链表，当链表长度大于8，且总数据量大于64的时候，链表就会转化成红黑树，所以你会看到Java8的Hashmap的数据存储是链表+红黑树的组合，如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树。</li></ul><p><strong>注：在jdk7中，当new Hashmap()的时候会对对象进行初始化，而jdk8中new Hashmap()并没有对对象进行初始化，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell学习笔记</title>
      <link href="/2021/11/29/shell/"/>
      <url>/2021/11/29/shell/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Shell的概述"><a href="#一-Shell的概述" class="headerlink" title="一.Shell的概述"></a>一.Shell的概述</h2><p>​    shell是一个<strong>命令解释器</strong>， 他接收应用户需/用户命令，然后调用操作系统内核。</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/15d9de6c7d92d622.jpg"></p><p>​    Shell还是一个功能相当强大的编程语言， 易编写、易调试、灵活性强。</p><h3 id="shell能做什么"><a href="#shell能做什么" class="headerlink" title="shell能做什么"></a>shell能做什么</h3><p>​        1，自动化批量系统初始化程序（update，软件安装，时区设置…）</p><p>​        2，自动化批量软件部署（LAMP，LNMP，Tomcat…）</p><p>​        3，管理应用程序</p><p>​        4，日志的分析处理程序（输出网站的访问量）</p><p>​        5，可以写自动化备份恢复程序（MySql完全备份/增量）</p><p>​        6，自动化管理程序（批量远程修改密码，软件的升级，配置更新）</p><p>​        7，自动化的信息采集及监控程序（收集系统/应用状态信息，CPU，      Mem，Net等）</p><p>​        8，配合Zabbix实现信息采集</p><p>​        9，可以写一个shell脚本实现自动化扩容</p><p>​        10，可以使用shell写小程序，比如俄罗斯方块</p><h2 id="二-Shell解析器"><a href="#二-Shell解析器" class="headerlink" title="二. Shell解析器"></a>二. Shell解析器</h2><h3 id="（1）Linux提供的Shell解析器有："><a href="#（1）Linux提供的Shell解析器有：" class="headerlink" title="（1）Linux提供的Shell解析器有："></a>（1）Linux提供的Shell解析器有：</h3><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop101 ~]$ cat /etc/shells /bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh</code></pre><h3 id="（2）bash和sh的关系"><a href="#（2）bash和sh的关系" class="headerlink" title="（2）bash和sh的关系"></a>（2）bash和sh的关系</h3><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop101 bin]$ ll | grep bash-rwxr-xr-x. 1 root root 941880 5月 11 2016 bashlrwxrwxrwx. 1 root root   4 5月 27 2017 sh -> bash</code></pre><h3 id="（3）Centos默认的解析器是bash"><a href="#（3）Centos默认的解析器是bash" class="headerlink" title="（3）Centos默认的解析器是bash"></a>（3）Centos默认的解析器是bash</h3><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop102 bin]$echo \$SHELL\bin\bash</code></pre><h2 id="三-shell脚本的执行方式"><a href="#三-shell脚本的执行方式" class="headerlink" title="三.shell脚本的执行方式"></a>三.shell脚本的执行方式</h2><h3 id="1．脚本格式"><a href="#1．脚本格式" class="headerlink" title="1．脚本格式"></a>1．脚本格式</h3><p>脚本以**#!/bin/bash**开头（指定解析器）</p><h3 id="2．第一个Shell脚本：helloworld"><a href="#2．第一个Shell脚本：helloworld" class="headerlink" title="2．第一个Shell脚本：helloworld"></a>2．第一个Shell脚本：helloworld</h3><h5 id="（1）需求：创建一个Shell脚本，输出helloworld"><a href="#（1）需求：创建一个Shell脚本，输出helloworld" class="headerlink" title="（1）需求：创建一个Shell脚本，输出helloworld"></a>（1）需求：创建一个Shell脚本，输出helloworld</h5><h5 id="（2）案例实操："><a href="#（2）案例实操：" class="headerlink" title="（2）案例实操："></a>（2）案例实操：</h5><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop101 datas]$ touch helloworld.sh[atguigu@hadoop101 datas]$ vi helloworld.sh 在helloworld.sh中输入如下内容\#!/bin/bashecho "helloworld"</code></pre><h5 id="（3）脚本的常用执行方式"><a href="#（3）脚本的常用执行方式" class="headerlink" title="（3）脚本的常用执行方式"></a>（3）脚本的常用执行方式</h5><p>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p><pre class=" language-sehll"><code class="language-sehll">  sh+脚本的相对路径[atguigu@hadoop101 datas]$ sh helloworld.sh Helloworld​    sh+脚本的绝对路径[atguigu@hadoop101 datas]$ sh /home/atguigu/datas/helloworld.sh helloworld​    bash+脚本的相对路径[atguigu@hadoop101 datas]$ bash helloworld.sh Helloworld​    bash+脚本的绝对路径[atguigu@hadoop101 datas]$ bash /home/atguigu/datas/helloworld.sh Helloworld</code></pre><p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p><pre class=" language-shell"><code class="language-shell">（a）首先要赋予helloworld.sh 脚本的+x权限[atguigu@hadoop101 datas]$ chmod 777 helloworld.sh（b）执行脚本相对路径[atguigu@hadoop101 datas]$ ./helloworld.sh Helloworld绝对路径[atguigu@hadoop101 datas]$ /home/atguigu/datas/helloworld.sh Helloworld注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</code></pre><p>3．第二个Shell脚本：多命令处理</p><pre class=" language-shell"><code class="language-shell">（1）需求：在/home/atguigu/目录下创建一个banzhang.txt,在banzhang.txt文件中增加“I love cls”。（2）案例实操：[atguigu@hadoop101 datas]$ touch batch.sh[atguigu@hadoop101 datas]$ vi batch.sh 在batch.sh中输入如下内容\#!/bin/bash cd /home/atguigutouch cls.txtecho "I love cls" >>cls.txt</code></pre><h2 id="四-Shell中的变量"><a href="#四-Shell中的变量" class="headerlink" title="四.Shell中的变量"></a>四.Shell中的变量</h2><h3 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h3><pre class=" language-shell"><code class="language-shell">\1. 常用系统变量$HOME、$PWD、$SHELL、$USER等2．案例实操（1）查看系统变量的值[atguigu@hadoop101 datas]$ echo $HOME/home/atguigu（2）显示当前Shell中所有变量：set[atguigu@hadoop101 datas]$ setBASH=/bin/bashBASH_ALIASES=()BASH_ARGC=()BASH_ARGV=()</code></pre><h3 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2 自定义变量"></a>4.2 自定义变量</h3><p>1．基本语法</p><p>（1）定义变量：变量=值 </p><p>（2）撤销变量：unset 变量</p><p>（3）声明静态变量：readonly变量，注意：不能unset</p><p>2．变量定义规则</p><p>​    （1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</p><p>​    （2）等号两侧不能有空格</p><p>​    （3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</p><p>​    （4）变量的值如果有空格，需要使用双引号或单引号括起来。</p><p>3．案例实操</p><pre class=" language-shell"><code class="language-shell">```（1）定义变量A[atguigu@hadoop101 datas]$ A=5[atguigu@hadoop101 datas]$ echo $A5​    （2）给变量A重新赋值[atguigu@hadoop101 datas]$ A=8[atguigu@hadoop101 datas]$ echo $A8​    （3）撤销变量A[atguigu@hadoop101 datas]$ unset A[atguigu@hadoop101 datas]$ echo $A​    （4）声明静态的变量B=2，不能unset[atguigu@hadoop101 datas]$ readonly B=2[atguigu@hadoop101 datas]$ echo $B2[atguigu@hadoop101 datas]$ B=9-bash: B: readonly variable​    （5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算[atguigu@hadoop102 ~]$ C=1+2[atguigu@hadoop102 ~]$ echo $C1+2（6）变量的值如果有空格，需要使用双引号或单引号括起来[atguigu@hadoop102 ~]$ D=I love banzhang-bash: world: command not found[atguigu@hadoop102 ~]$ D="I love banzhang"[atguigu@hadoop102 ~]$ echo $AI love banzhang​    （7）可把变量提升为全局环境变量，可供其他Shell程序使用export 变量名[atguigu@hadoop101 datas]$ vim helloworld.sh   在helloworld.sh文件中增加echo $B​    ​    \#!/bin/bash​     ​    ​    echo "helloworld"​    ​    echo $B​     ​    ​    [atguigu@hadoop101 datas]$ ./helloworld.sh ​    ​    Helloworld​    </code></pre><p>​    发现并没有打印输出变量B的值。<br>​    </p><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop101 datas]$ export B[atguigu@hadoop101 datas]$ ./helloworld.sh helloworld2```</code></pre><h3 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h3><p>1．基本语法</p><p>​    $n  （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）</p><p>2．案例实操</p><p>（1）输出该脚本文件名称、输入参数1和输入参数2 的值</p><pre class=" language-shell"><code class="language-shell">  [atguigu@hadoop101 datas]$ touch parameter.sh     [atguigu@hadoop101 datas]$ vim parameter.sh         \#!/bin/bash    echo "$0 $1  $2"         [atguigu@hadoop101 datas]$ chmod 777 parameter.sh         [atguigu@hadoop101 datas]$ ./parameter.sh cls xz    ./parameter.sh cls  xz</code></pre><h3 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$#"></a>4.4 特殊变量：$#</h3><p>1．基本语法</p><p>​    $#  （功能描述：获取所有输入参数个数，常用于循环）。</p><p>2．案例实操</p><p>（1）获取输入参数的个数</p><pre class=" language-shell"><code class="language-shell">  [atguigu@hadoop101 datas]$ vim parameter.sh         \#!/bin/bash    echo "$0 $1  $2"    echo $#         [atguigu@hadoop101 datas]$ chmod 777 parameter.sh         [atguigu@hadoop101 datas]$ ./parameter.sh cls xz    parameter.sh cls xz     2</code></pre><h3 id="4-5-特殊变量：-、"><a href="#4-5-特殊变量：-、" class="headerlink" title="4.5 特殊变量：$*、$@"></a>4.5 特殊变量：$*、$@</h3><p>1．基本语法</p><p>​    $*  （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>​    $@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p><p>2．案例实操</p><p>（1）打印输入的所有参数</p><pre class=" language-shell"><code class="language-shell">  [atguigu@hadoop101 datas]$ vim parameter.sh         \#!/bin/bash    echo "$0 $1  $2"    echo $#    echo $*    echo $@         [atguigu@hadoop101 datas]$ bash parameter.sh 1 2 3    parameter.sh 1  2    3    1 2 3    1 2 3</code></pre><h3 id="4-6-特殊变量：-？"><a href="#4-6-特殊变量：-？" class="headerlink" title="4.6 特殊变量：$？"></a>4.6 特殊变量：$？</h3><p>1．基本语法</p><p>$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p><p>2．案例实操</p><p>​    （1）判断helloworld.sh脚本是否正确执行</p><p>​        [atguigu@hadoop101 datas]$ ./helloworld.sh </p><p>​        hello world</p><p>​        [atguigu@hadoop101 datas]$ echo ​$?</p><h2 id="五-运算符"><a href="#五-运算符" class="headerlink" title="五.运算符"></a>五.运算符</h2><h3 id="1．基本语法"><a href="#1．基本语法" class="headerlink" title="1．基本语法"></a>1．基本语法</h3><p>（1）“$((运算式))”或“$[运算式]”</p><p>（2）expr  + , - , *, /, %  加，减，乘，除，取余</p><p>  <strong>注意：expr运算符间要有空格</strong></p><h3 id="2．案例实操："><a href="#2．案例实操：" class="headerlink" title="2．案例实操："></a>2．案例实操：</h3><pre class=" language-shell"><code class="language-shell">（1）计算3+2的值   [atguigu@hadoop101 datas]$ expr 2 + 3   5（2）计算3-2的值   [atguigu@hadoop101 datas]$ expr 3 - 2    1（3）计算（2+3）X4的值​    （a）expr一步完成计算​     [atguigu@hadoop101 datas]$ expr `expr 2 + 3` \* 4​     20（b）采用$[运算式]方式   [atguigu@hadoop101 datas]# S=$[(2+3)*4]   [atguigu@hadoop101 datas]# echo $S    </code></pre><h2 id="六-条件判断"><a href="#六-条件判断" class="headerlink" title="六.条件判断"></a>六.条件判断</h2><h3 id="1．基本语法-1"><a href="#1．基本语法-1" class="headerlink" title="1．基本语法"></a>1．基本语法</h3><p>[ condition ]（注意condition前后要有空格）</p><p>注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。</p><h3 id="2-常用判断条件"><a href="#2-常用判断条件" class="headerlink" title="2.常用判断条件"></a>2.常用判断条件</h3><p>（1）两个整数之间比较</p><p>​        = 字符串比较</p><p>​        -lt 小于（less than）         -le 小于等于（less equal）</p><p>​        -eq 等于（equal）           -gt 大于（greater than）</p><p>​        -ge 大于等于（greater equal）  -ne 不等于（Not equal）</p><p>（2）按照文件权限进行判断</p><p>​        -r 有读的权限（read）       -w 有写的权限（write）</p><p>​        -x 有执行的权限（execute）</p><p>（3）按照文件类型进行判断</p><p>​        -f 文件存在并且是一个常规的文件（file）</p><p>​        -e 文件存在（existence）     -d 文件存在并是一个目录（directory）</p><p>3．案例实操</p><pre><code>~~~shell</code></pre><p>（1）23是否大于等于22</p><p>​                [atguigu@hadoop101 datas]$ [ 23 -ge 22 ]</p><p>​                [atguigu@hadoop101 datas]$ echo ​$?</p><p>​                0</p><p>​    （2）helloworld.sh是否具有写权限</p><p>​                [atguigu@hadoop101 datas]$ [ -w helloworld.sh ]</p><p>​                [atguigu@hadoop101 datas]$ echo $$?</p><p>​                0</p><p>​    （3）/home/atguigu/cls.txt目录中的文件是否存在</p><p>​        [atguigu@hadoop101 datas]$ [ -e /home/atguigu/cls.txt ]</p><p>​        [atguigu@hadoop101 datas]$ echo $?</p><p>​        1</p><p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）</p><p>​        [atguigu@hadoop101 ~]$ [ condition ] &amp;&amp; echo OK || echo notok</p><p>​        OK</p><p>​        [atguigu@hadoop101 datas]$ [ condition ] &amp;&amp; [ ] || echo notok</p><p>​        notok<br>    ~~~</p><h2 id="七-流程控制"><a href="#七-流程控制" class="headerlink" title="七.流程控制"></a>七.流程控制</h2><p>​    1．基本语法</p><p>​        if [ 条件判断式 ];then </p><pre><code>     程序 </code></pre><p>​        fi </p><p>​        或者 </p><p>​        if [ 条件判断式 ] </p><pre><code>     then        程序 </code></pre><p>​        fi</p><p>​    <strong>注意事项：</strong></p><p>​        （1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格</p><p>​        （2）if后要有空格</p><p>2．案例实操</p><pre class=" language-shell"><code class="language-shell">（1）输入一个数字，如果是1，则输出banzhang zhen shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。[atguigu@hadoop101 datas]$ touch if.sh[atguigu@hadoop101 datas]$ vim if.sh \#!/bin/bash if [ $1 -eq "1" ]then​    echo "banzhang zhen shuai"elif [ $1 -eq "2" ]then​    echo "cls zhen mei"fi [atguigu@hadoop101 datas]$ chmod 777 if.sh [atguigu@hadoop101 datas]$ ./if.sh 1banzhang zhen shuai</code></pre><h2 id="7-2-case-语句"><a href="#7-2-case-语句" class="headerlink" title="7.2 case 语句"></a>7.2 case 语句</h2><p>​    1．基本语法</p><p>​        case $变量名 in </p><pre><code>     "值1"）        如果变量的值等于值1，则执行程序1       ;;      "值2"）    如果变量的值等于值2，则执行程序2        ;;  …省略其他分支…   *）   如果变量的值都不是以上的值，则执行此程序    ;;</code></pre><p>​    esac</p><p><strong>注意事项：</strong></p><ol><li><p>   case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</p></li><li><p>   双分号“**;;**”表示命令序列结束，相当于java中的break。</p></li><li><p>   最后的“*）”表示默认模式，相当于java中的default。</p></li></ol><p>2．案例实操</p><pre class=" language-shell"><code class="language-shell">（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。[atguigu@hadoop101 datas]$ touch case.sh[atguigu@hadoop101 datas]$ vim case.sh !/bin/bash case $1 in"1")​    echo "banzhang";; "2")​    echo "cls";;*)​    echo "renyao";;esac [atguigu@hadoop101 datas]$ chmod 777 case.sh[atguigu@hadoop101 datas]$ ./case.sh 11</code></pre><h2 id="7-3-for-循环"><a href="#7-3-for-循环" class="headerlink" title="7.3 for 循环"></a>7.3 for 循环</h2><p>1．基本语法1</p><p>​    <strong>for</strong> (( 初始值;循环控制条件;变量变化 )) </p><p>   <strong>do</strong> </p><pre><code>      程序 </code></pre><p> <strong>done</strong></p><p>2．案例实操</p><pre class=" language-shell"><code class="language-shell">（1）从1加到100[atguigu@hadoop101 datas]$ touch for1.sh[atguigu@hadoop101 datas]$ vim for1.sh \#!/bin/bash s=0for((i=0;i<=100;i++))do​    s=$[$s+$i]doneecho $s [atguigu@hadoop101 datas]$ chmod 777 for1.sh [atguigu@hadoop101 datas]$ ./for1.sh “5050”</code></pre><p>3．基本语法2</p><p>for 变量 in 值1 值2 值3… </p><p> do </p><p>  程序 </p><p> done</p><p>4．案例实操</p><pre class=" language-shell"><code class="language-shell">```（1）打印所有输入参数​        [atguigu@hadoop101 datas]$ touch for2.sh​        [atguigu@hadoop101 datas]$ vim for2.sh</code></pre><p>​<br>​<br>​    #!/bin/bash<br>​<br>​    #打印数字</p><p>​<br>​<br>​    for i in $*<br>​<br>​      do<br>​<br>​       echo “ban zhang love $i “<br>​<br>      done</p><p>​<br>​<br>​    [atguigu@hadoop101 datas]$ chmod 777 for2.sh<br>​<br>​    [atguigu@hadoop101 datas]$ bash for2.sh cls xz bd<br>​<br>​    ban zhang love cls<br>​    </p><pre class=" language-shell"><code class="language-shell">ban zhang love xzban zhang love bd（2）比较$*和$@区别（a）$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n的形式输出所有参数。  [atguigu@hadoop101 datas]$ touch for.sh  [atguigu@hadoop101 datas]$ vim for.sh     #!/bin/bash      for i in $*  do     echo "ban zhang  love $i "  done     for j in $@  do         echo "ban  zhang love $j"  done     [atguigu@hadoop101 datas]$ bash for.sh cls xz bd  ban zhang love  cls   ban zhang love  xz   ban zhang love  bd   ban zhang love  cls  ban zhang love  xz  ban zhang love  bd  （b）当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输出所有参数；“$@”会将各个参数分开，以“$1” “$2”…”$n”的形式输出所有参数。[atguigu@hadoop101 datas]$ vim for.sh</code></pre><p>​<br>​<br>​    #!/bin/bash</p><p>​<br>​<br>​    for i in “$*”<br>​<br>​    #$*中的所有参数看成是一个整体，所以这个for循环只会循环一次<br>​<br>​        do<br>​    </p><pre class=" language-shell"><code class="language-shell">        echo "ban zhang love $i"​    done </code></pre><p>​<br>​<br>​    for j in “$@”<br>​<br>​    #$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次<br>​<br>​        do<br>​    </p><pre class=" language-shell"><code class="language-shell">        echo "ban zhang love $j" done</code></pre><p>​<br>​    [atguigu@hadoop101 datas]$ chmod 777 for.sh<br>​<br>​    [atguigu@hadoop101 datas]$ bash for.sh cls xz bd<br>​<br>​    ban zhang love cls xz bd<br>​    </p><pre class=" language-shell"><code class="language-shell">ban zhang love clsban zhang love xzban zhang love bd```</code></pre><h2 id="7-4-while-循环"><a href="#7-4-while-循环" class="headerlink" title="7.4 while 循环"></a>7.4 while 循环</h2><p>1．基本语法</p><p>while [ 条件判断式 ] </p><p> do </p><p>  程序</p><p> done</p><p>2．案例实操</p><pre class=" language-shell"><code class="language-shell">```shell（1）从1加到100[atguigu@hadoop101 datas]$ touch while.sh[atguigu@hadoop101 datas]$ vim while.sh    </code></pre><pre class=" language-shell"><code class="language-shell">while [ $i -le 100 ]do​    s=$[$s+$i]​    i=$[$i+1]done</code></pre><p>​     </p><h1 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h1><h2 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h2><p>1．basename基本语法</p><p>​        basename [string / pathname] [suffix]     （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。</p><p>选项：</p><p>​        suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p>2．案例实操</p><p>​        （1）截取该/home/atguigu/banzhang.txt路径的文件名称</p><p>​        [atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt</p><p>​        banzhang.txt</p><p>​        [atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt</p><p>​        banzhang</p><p>\3.  dirname基本语法</p><pre><code>    dirname 文件绝对路径    （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</code></pre><p>4．案例实操</p><p>​    （1）获取banzhang.txt文件的路径</p><p>​        [atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt </p><p>​        /home/atguigu</p><h2 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h2><p>1．基本语法</p><p>​        [ function ] funname[()]</p><p>​        {</p><pre><code>        Action;</code></pre><p>​            [return int;]</p><p>​        }</p><p>​        funname</p><p>2．经验技巧</p><p>​    （1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。</p><p>​    （2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)</p><p>3．案例实操</p><pre class=" language-shell"><code class="language-shell">   （1）计算两个输入参数的和[atguigu@hadoop101 datas]$ touch fun.sh[atguigu@hadoop101 datas]$ vim fun.sh \#!/bin/bashfunction sum(){  s=0  s=$[ $1 + $2 ]  echo "$s"} read -p "Please input the number1: " n1;read -p "Please input the number2: " n2;sum $n1 $n2; [atguigu@hadoop101 datas]$ chmod 777 fun.sh[atguigu@hadoop101 datas]$ ./fun.sh Please input the number1: 2Please input the number2: 57</code></pre><h1 id="第10章-Shell工具（重点）"><a href="#第10章-Shell工具（重点）" class="headerlink" title="第10章 Shell工具（重点）"></a>第10章 Shell工具（重点）</h1><h2 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h2><p>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><p>1.基本用法</p><p>cut [选项参数]  filename</p><p>说明：默认分隔符是制表符</p><p>2.选项参数说明</p><p>表1-55</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>列号，提取第几列</td></tr><tr><td>-d</td><td>分隔符，按照指定分隔符分割列</td></tr></tbody></table><p>3.案例实操</p><pre class=" language-shell"><code class="language-shell">（0）数据准备[atguigu@hadoop101 datas]$ touch cut.txt[atguigu@hadoop101 datas]$ vim cut.txtdong shenguan zhenwo wolai laile le（1）切割cut.txt第一列[atguigu@hadoop101 datas]$ cut -d " " -f 1 cut.txt dongguanwolaile（2）切割cut.txt第二、三列[atguigu@hadoop101 datas]$ cut -d " " -f 2,3 cut.txt shenzhen wo lai le（3）在cut.txt文件中切割出guan[atguigu@hadoop101 datas]$ cat cut.txt | grep "guan" | cut -d " " -f 1guan（4）选取系统PATH变量值，第2个“：”开始后的所有路径：[atguigu@hadoop101 datas]$ echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin [atguigu@hadoop102 datas]$ echo $PATH | cut -d: -f 2-/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin（5）切割ifconfig 后打印的IP地址[atguigu@hadoop101 datas]$ ifconfig eth0 | grep "inet addr" | cut -d: -f 2 | cut -d" " -f1192.168.1.102</code></pre><h2 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h2><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><ol><li>基本用法</li></ol><p>sed [选项参数]  ‘command’ filename</p><ol start="2"><li>选项参数说明</li></ol><p>表1-56</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>直接在指令列模式上进行sed的动作编辑。</td></tr></tbody></table><ol start="3"><li>命令功能描述</li></ol><p>表1-57</p><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td><em>a</em></td><td>新增，a的后面可以接字串，在下一行出现</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>s</td><td>查找并替换</td></tr></tbody></table><ol start="4"><li>案例实操</li></ol><pre class=" language-shell"><code class="language-shell">（0）数据准备[atguigu@hadoop102 datas]$ touch sed.txt[atguigu@hadoop102 datas]$ vim sed.txtdong shenguan zhenwo wolai lai le le（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。[atguigu@hadoop102 datas]$ sed '2a mei nv' sed.txt dong shenguan zhenmei nvwo wolai lai le le[atguigu@hadoop102 datas]$ cat sed.txt dong shenguan zhenwo wolai lai le le注意：文件并没有改变（2）删除sed.txt文件所有包含wo的行[atguigu@hadoop102 datas]$ sed '/wo/d' sed.txtdong shenguan zhenlai lai le le（3）将sed.txt文件中wo替换为ni[atguigu@hadoop102 datas]$ sed 's/wo/ni/g' sed.txt dong shenguan zhenni nilai lai le le注意：‘g’表示global，全部替换（4）将sed.txt文件中的第二行删除并将wo替换为ni[atguigu@hadoop102 datas]$ sed -e '2d' -e 's/wo/ni/g' sed.txt dong shenni nilai lai le le</code></pre><h2 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h2><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><ol><li>基本用法</li></ol><p>awk [选项参数] ‘pattern1{action1} pattern2{action2}…’ filename</p><p>pattern：表示AWK在数据中查找的内容，就是匹配模式</p><p>action：在找到匹配内容时所执行的一系列命令</p><ol start="2"><li>选项参数说明</li></ol><p>表1-55</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件折分隔符</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><ol start="3"><li>  案例实操</li></ol><pre class=" language-shell"><code class="language-shell">（0）数据准备[atguigu@hadoop102 datas]$ sudo cp /etc/passwd ./（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。[atguigu@hadoop102 datas]$ awk -F: '/^root/{print $7}' passwd /bin/bash（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。[atguigu@hadoop102 datas]$ awk -F: '/^root/{print $1","$7}' passwd root,/bin/bash注意：只有匹配了pattern的行才会执行action（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加"dahaige，/bin/zuishuai"。[atguigu@hadoop102 datas]$ awk -F : 'BEGIN{print "user, shell"} {print $1","$7} END{print "dahaige,/bin/zuishuai"}' passwduser, shellroot,/bin/bashbin,/sbin/nologin。。。atguigu,/bin/bashdahaige,/bin/zuishuai注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。（4）将passwd文件中的用户id增加数值1并输出[atguigu@hadoop102 datas]$ awk -v i=1 -F: '{print $3+i}' passwd1234</code></pre><ol start="4"><li>  awk的内置变量</li></ol><p>表1-56</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数</td></tr><tr><td>NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table><ol start="5"><li>案例实操</li></ol><pre class=" language-shell"><code class="language-shell">（1）统计passwd文件名，每行的行号，每行的列数[atguigu@hadoop102 datas]$ awk -F: '{print "filename:" FILENAME ", linenumber:" NR ",columns:" NF}' passwd filename:passwd, linenumber:1,columns:7filename:passwd, linenumber:2,columns:7filename:passwd, linenumber:3,columns:7​     （2）切割IP[atguigu@hadoop102 datas]$ ifconfig eth0 | grep "inet addr" | awk -F: '{print $2}' | awk -F " " '{print $1}' 192.168.1.102​     （3）查询sed.txt中空行所在的行号[atguigu@hadoop102 datas]$ awk '/^\$/{print NR}' sed.txt 5</code></pre><h2 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h2><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p><p>\1.   基本语法</p><p>sort(选项)(参数)</p><p>表1-57</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>依照数值的大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><p>参数：指定待排序的文件列表</p><ol start="2"><li>案例实操</li></ol><p>（0）数据准备</p><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop102 datas]$ touch sort.sh[atguigu@hadoop102 datas]$ vim sort.sh bb:40:5.4bd:20:4.2xz:50:2.3cls:10:3.5ss:30:1.6</code></pre><p>（1）按照“：”分割后的第三列倒序排序。</p><pre class=" language-shell"><code class="language-shell">[atguigu@hadoop102 datas]$ sort -t : -nrk 3 sort.sh bb:40:5.4bd:20:4.2cls:10:3.5xz:50:2.3ss:30:1.6</code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2021/11/28/mybatis/"/>
      <url>/2021/11/28/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-、什么是-Mybatis-？"><a href="#1-、什么是-Mybatis-？" class="headerlink" title="1 、什么是 Mybatis ？"></a>1 、什么是 Mybatis ？</h2><p>（ 1 ） Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开<br>发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、<br>创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制<br>sql 执行性能，灵活度高。<br>（ 2 ） MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成<br>数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果<br>集。<br>（ 3 ） 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通<br>过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql<br>语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。<br>（从执行 sql 到返回 result 的过程）。</p><h2 id="2-、-Mybaits-的优点："><a href="#2-、-Mybaits-的优点：" class="headerlink" title="2 、 Mybaits 的优点："></a>2 、 Mybaits 的优点：</h2><p>（ 1 ） 基 于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计</p><p>造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管<br>理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。<br>（ 2 ） 与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代<br>码，不需要手动开关连接；<br>（ 3 ） 很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所<br>以只要 JDBC 支持的数据库 MyBatis 都支持）。<br>（ 4 ） 能够与 Spring 很好的集成；<br>（ 5 ） 提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系<br>映射标签，支持对象关系组件维护。</p><h2 id="3-、-MyBatis-框架的缺点："><a href="#3-、-MyBatis-框架的缺点：" class="headerlink" title="3 、 MyBatis 框架的缺点："></a>3 、 MyBatis 框架的缺点：</h2><p>（ 1 ） SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编</p><h3 id="写-SQL-语句的功底有一定要求。"><a href="#写-SQL-语句的功底有一定要求。" class="headerlink" title="写 SQL 语句的功底有一定要求。"></a>写 SQL 语句的功底有一定要求。</h3><p>（ 2 ） SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h2 id="4-、-MyBatis-框架适用场合："><a href="#4-、-MyBatis-框架适用场合：" class="headerlink" title="4 、 MyBatis 框架适用场合："></a>4 、 MyBatis 框架适用场合：</h2><p>（ 1 ） MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>（ 2 ） 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis<br>将是不错的选择。</p><h2 id="5-、-MyBatis-与-Hibernate-有哪些不同？"><a href="#5-、-MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="5 、 MyBatis 与 Hibernate 有哪些不同？"></a>5 、 MyBatis 与 Hibernate 有哪些不同？</h2><p>（ 1 ） Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis<br>需要程序员自己编写 Sql 语句。<br>（ 2 ） Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度<br>高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频<br>繁，一但需求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数<br>据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映<br>射文件，工作量大。<br>（ 3 ） Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求<br>高的软件，如果用 hibernate 开发可以节省很多代码，提高效率。</p><h2 id="6-、-和-的区别是什么？"><a href="#6-、-和-的区别是什么？" class="headerlink" title="6 、 #{} 和 ${} 的区别是什么？"></a>6 、 #{} 和 ${} 的区别是什么？</h2><h3 id="是预编译处理，-是字符串替换。"><a href="#是预编译处理，-是字符串替换。" class="headerlink" title="#{}是预编译处理，${}是字符串替换。"></a>#{}是预编译处理，${}是字符串替换。</h3><p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用<br>PreparedStatement 的 set 方法来赋值；<br>Mybatis 在处理${}时，就是把${}替换成变量的值。使<br>用#{}可以有效的防止 SQL 注入，提高系统安全性。</p><h2 id="7-、当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#7-、当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="7 、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>7 、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h2><p>第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实<br>体类的属性名一致。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectorder”</span> <span class="token attr-name">parametertype</span><span class="token attr-value"><span class="token punctuation">=</span>”int”</span> <span class="token attr-name">resultetype</span><span class="token attr-value"><span class="token punctuation">=</span>”</span>    <span class="token attr-name">me.gacl.domain.order”</span><span class="token punctuation">></span></span>    select order_id id, order_no orderno ,order_price price form    orders where order_id=#{id};<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>第 2 种： 通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getOrder<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span>    <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orderresultmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from orders where order_id=#{id}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>me.gacl.domain.order<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orderresultmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--用 id 属性来映射主键字段--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--用 result 属性来映射非主键字段，property 为实体类属性名，column为数据表中的属性--></span>    &lt;result property = “orderno" column =”order_no"/>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_price<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>reslutMap</span><span class="token punctuation">></span></span></code></pre><h2 id="8-、-模糊查询-like-语句该怎么写"><a href="#8-、-模糊查询-like-语句该怎么写" class="headerlink" title="8 、 模糊查询 like 语句该怎么写?"></a>8 、 模糊查询 like 语句该怎么写?</h2><pre class=" language-xml"><code class="language-xml">第 1 种：在 Java 代码中添加 sql 通配符。string wildcardname = “%smi%”;list<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span> names = mapper.selectlike(wildcardname);<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectlike”</span><span class="token punctuation">></span></span>select * from foo where bar like #{value}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    第 2 种：在 sql 语句中拼接通配符，会引起 sql 注入string wildcardname = “smi”;list<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span> names = mapper.selectlike(wildcardname);<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>”selectlike”</span><span class="token punctuation">></span></span>select * from foo where bar like "%"#{value}"%"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>##9 、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问， 这个 Dao</p><p>这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，</p><p>方法能重载吗？</p><pre><code>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MapperStatement 对象。举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为findStudentById 的 MapperStatement。Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用JDK 动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</code></pre><h2 id="10-、-Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#10-、-Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="10 、 Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>10 、 Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><pre><code>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根 据 dialect 方言，添加对应的物理分页语句和物理分页参数。</code></pre><h2 id="11-、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有"><a href="#11-、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有" class="headerlink" title="11 、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有"></a>11 、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有</h2><h2 id="哪些映射形式？"><a href="#哪些映射形式？" class="headerlink" title="哪些映射形式？"></a>哪些映射形式？</h2><p>第一种是使用<resultmap>标签，逐一定义数据库列名和对象属性名之间的映射<br>关系。<br>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。<br>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射<br>给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值<br>的。</resultmap></p><h2 id="12-、如何执行批量插入"><a href="#12-、如何执行批量插入" class="headerlink" title="12 、如何执行批量插入?"></a>12 、如何执行批量插入?</h2><p>首先,创建一个简单的 insert 语句:</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">/</span>insert<span class="token operator">></span>    insert into <span class="token function">names</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token function">values</span> <span class="token punctuation">(</span>#<span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>insert<span class="token operator">></span>然后在 java 代码中像下面这样执行批处理插入<span class="token operator">:</span>list <span class="token operator">&lt;</span> string <span class="token operator">></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">arraylist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“fred”<span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“barney”<span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“betty”<span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“wilma”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 注意这里 executortype.batch</span>sqlsession sqlsession <span class="token operator">=</span>sqlsessionfactory<span class="token punctuation">.</span><span class="token function">opensession</span><span class="token punctuation">(</span>executortype<span class="token punctuation">.</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>namemapper mapper <span class="token operator">=</span> sqlsession<span class="token punctuation">.</span><span class="token function">getmapper</span><span class="token punctuation">(</span>namemapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>string name<span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>mapper<span class="token punctuation">.</span><span class="token function">insertname</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>sqlsession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sqlSession<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>sqlsession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="13-、如何获取自动生成的-主-键值"><a href="#13-、如何获取自动生成的-主-键值" class="headerlink" title="13 、如何获取自动生成的 ( 主 ) 键值?"></a>13 、如何获取自动生成的 ( 主 ) 键值?</h2><p>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到<br>传入的参数对象中。<br>示例：<br>&lt;insert id=”insertname” usegeneratedkeys=”true” keyproperty=”<br>id”&gt;<br>insert into names (name) values (#{<br>name<br>}<br>)<br><br>name name = new name();<br>name.setname(“fred”);<br>int rows = mapper.insertname(name);<br>// 完成后,id 已经被设置到对象中<br>system.out.println(“rows inserted = ” + rows);<br>system.out.println(“generated key value = ” + name.getid());复制代<br>码</p><h2 id="14-、在-mapper-中如何传递多个参数"><a href="#14-、在-mapper-中如何传递多个参数" class="headerlink" title="14 、在 mapper 中如何传递多个参数?"></a>14 、在 mapper 中如何传递多个参数?</h2><h3 id="第一种：DAO-层的函数"><a href="#第一种：DAO-层的函数" class="headerlink" title="第一种：DAO 层的函数"></a>第一种：DAO 层的函数</h3><p>public UserselectUser(String name,String area);<br>对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第<br>二参数，更多参数一致往后加即可。</p><p>&lt;select id=”selectUser”resultMap=”BaseResultMap”&gt;<br>select * fromuser_user_t whereuser_name = #{0}<br>anduser_area=#{1}<br>复制代码<br>第二种： 使用 @param 注解:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">usermapper</span> <span class="token punctuation">{</span>user <span class="token function">selectuser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@param</span><span class="token punctuation">(</span>“username”<span class="token punctuation">)</span> stringusername<span class="token punctuation">,</span><span class="token annotation punctuation">@param</span><span class="token punctuation">(</span>“hashedpassword”<span class="token punctuation">)</span> string hashedpassword<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递<br>给 mapper):</p><pre><code>&lt;select id=”selectuser” resulttype=”user”&gt;    select id, username, hashedpassword    from some_table    where username = #{username}    and hashedpassword = #{hashedpassword}&lt;/select&gt;第三种：多个参数封装成 maptry {//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的SQL//由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此我们使用 Map 集合来装载我们的参数Map &lt; String, Object &gt; map = new HashMap();map.put("start", start);map.put("end", end);return sqlSession.selectList("StudentID.pagination", map);}catch (Exception e) {e.printStackTrace();sqlSession.rollback();throw e;}finally {MybatisUtil.closeSqlSession();}</code></pre><h2 id="15-、-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql-？"><a href="#15-、-Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql-？" class="headerlink" title="15 、 Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql ？"></a>15 、 Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql ？</h2><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执<br>行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。<br>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if |<br>choose| when | otherwise | bind。</p><h2 id="16-、Xml-映射文件中，除了常见的-select-insert-updae-delete-标"><a href="#16-、Xml-映射文件中，除了常见的-select-insert-updae-delete-标" class="headerlink" title="16 、Xml 映射文件中，除了常见的 select|insert|updae|delete 标"></a>16 、Xml 映射文件中，除了常见的 select|insert|updae|delete 标</h2><h2 id="签之外，还有哪些标签？"><a href="#签之外，还有哪些标签？" class="headerlink" title="签之外，还有哪些标签？"></a>签之外，还有哪些标签？</h2><p>答：<resultmap>、<parametermap>、<sql>、<include>、<selectkey>，加上<br>动态 sql 的 9 个标签，其中<sql>为 sql 片段标签，通过<include>标签引入<br>sql 片段，<selectkey>为不支持自增的主键生成策略标签。</selectkey></include></sql></selectkey></include></sql></parametermap></resultmap></p><h2 id="17-、-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，-id-是否可以重复？"><a href="#17-、-Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，-id-是否可以重复？" class="headerlink" title="17 、 Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件， id 是否可以重复？"></a>17 、 Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件， id 是否可以重复？</h2><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有<br>配置 namespace，那么 id 不能重复；<br>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key 使用<br>的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。<br>有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然<br>也就不同。</p><h2 id="18-、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#18-、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="18 、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>18 、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h2><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关<br>联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而<br>Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，<br>称之为半自动 ORM 映射工具。</p><h2 id="19-、-一对一、一对多的关联查询-？"><a href="#19-、-一对一、一对多的关联查询-？" class="headerlink" title="19 、 一对一、一对多的关联查询 ？"></a>19 、 一对一、一对多的关联查询 ？</h2><pre><code>&lt;mapper namespace="com.lcb.mapping.userMapper"&gt;&lt;!--association 一对一关联查询 --&gt;&lt;select id="getClass" parameterType="int"    resultMap="ClassesResultMap"&gt;    select * from class c,teacher t where c.teacher_id=t.t_id and    c.c_id=#{id}    &lt;/select&gt;&lt;resultMap type="com.lcb.user.Classes" id="ClassesResultMap"&gt;    &lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;    &lt;id property="id" column="c_id"/&gt;    &lt;result property="name" column="c_name"/&gt;    &lt;association property="teacher"    javaType="com.lcb.user.Teacher"&gt;    &lt;id property="id" column="t_id"/&gt;    &lt;result property="name" column="t_name"/&gt;    &lt;/association&gt;    &lt;/resultMap&gt;&lt;!--collection 一对多关联查询 --&gt;    &lt;select id="getClass2" parameterType="int"        resultMap="ClassesResultMap2"&gt;        select * from class c,teacher t,student s where c.teacher_id=t.t_id        and c.c_id=s.class_id and c.c_id=#{id}    &lt;/select&gt;        &lt;resultMap type="com.lcb.user.Classes" id="ClassesResultMap2"&gt;        &lt;id property="id" column="c_id"/&gt;        &lt;result property="name" column="c_name"/&gt;        &lt;association property="teacher"        javaType="com.lcb.user.Teacher"&gt;        &lt;id property="id" column="t_id"/&gt;        &lt;result property="name" column="t_name"/&gt;    &lt;/association&gt;        &lt;collection property="student"        ofType="com.lcb.user.Student"&gt;        &lt;id property="id" column="s_id"/&gt;        &lt;result property="name" column="s_name"/&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;/mapper&gt;</code></pre><h2 id="20-、-MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#20-、-MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="20 、 MyBatis 实现一对一有几种方式? 具体怎么操作的？"></a>20 、 MyBatis 实现一对一有几种方式? 具体怎么操作的？</h2><h3 id="有联合查询和嵌套查询-联合查询是几个表联合查询-只查询一次-通过在"><a href="#有联合查询和嵌套查询-联合查询是几个表联合查询-只查询一次-通过在" class="headerlink" title="有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在"></a>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在</h3><p>resultMap 里面配置 association 节点配置一对一的类就可以完成；嵌套查询<br>是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询<br>数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配<br>置。</p><h2 id="21-、-MyBatis-实现一对多有几种方式-怎么操作的？"><a href="#21-、-MyBatis-实现一对多有几种方式-怎么操作的？" class="headerlink" title="21 、 MyBatis 实现一对多有几种方式 , 怎么操作的？"></a>21 、 MyBatis 实现一对多有几种方式 , 怎么操作的？</h2><p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</p><h2 id="22-、-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#22-、-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="22 、 Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>22 、 Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延<br>迟加载，association 指的就是一对一，collection 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="23-、-Mybatis-的一级、二级缓存"><a href="#23-、-Mybatis-的一级、二级缓存" class="headerlink" title="23 、 Mybatis 的一级、二级缓存 :"></a>23 、 Mybatis 的一级、二级缓存 :</h2><p>1 ） 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。<br>2 ） 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> 3 ） 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</cache></p><h2 id="24-、什么是-MyBatis-的接口绑定？有哪些实现方式？"><a href="#24-、什么是-MyBatis-的接口绑定？有哪些实现方式？" class="headerlink" title="24 、什么是 MyBatis 的接口绑定？有哪些实现方式？"></a>24 、什么是 MyBatis 的接口绑定？有哪些实现方式？</h2><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。接口绑定有两种实现方式,一种是通过注解绑定，就是在接口方法上面加上@Select、@Update 等注解，里面包含 Sql 语句来绑定；另外一种就是过xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的namespace 必为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定,当 SQL 语句比较复杂时候,用xml 绑定,一般用 xml 绑定的比较多。</p><h2 id="25-、使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#25-、使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="25 、使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>25 、使用 MyBatis 的 mapper 接口调用时有哪些要求？</h2><p>（ 1 ） Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；<br>（ 2 ） Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的<br>parameterType 的类型相同；<br>（ 3 ） Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的<br>resultType 的类型相同；<br>（ 4 ） Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</p><h2 id="26-、-Mapper-编写有哪几种方式？"><a href="#26-、-Mapper-编写有哪几种方式？" class="headerlink" title="26 、 Mapper 编写有哪几种方式？"></a>26 、 Mapper 编写有哪几种方式？</h2><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写<br>mapper 接口，mapper 接口实现类、mapper.xml 文件。<br>（ 1 ） 在 sqlMapConfig.xml 中配置 mapper.xml 的位置<br><mappers><br><mapper resource="mapper.xml 文件的地址"><br><mapper resource="mapper.xml 文件的地址"><br></mapper></mapper></mappers><br>（ 2 ） 定义 mapper 接口<br>（ 3 ） 实现类集成 SqlSessionDaoSupport<br>mapper 方法中可以 this.getSqlSession()进行数据增删改查。<br>（ 4 ） spring 配置<br><bean id=" " class="mapper 接口的实现"><br><property name="sqlSessionFactory" ref="sqlSessionFactory"></property><br></bean><br>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：<br>（ 1 ） 在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和<br>mappre 接口的名称相同且在同一个目录，这里可以不用配置<br><mappers><br><mapper resource="mapper.xml 文件的地址"><br><mapper resource="mapper.xml 文件的地址"><br></mapper></mapper></mappers><br>（ 2 ） 定义 mapper 接口：<br>（ 3 ） mapper.xml 中的 namespace 为 mapper 接口的地址<br>（ 4 ） mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保<br>持一致<br>（ 5 ） Spring 中定义<br><bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean"><br><property name="mapperInterface" value="mapper 接口地址"><br><property name="sqlSessionFactory" ref="sqlSessionFactory"><br></property></property></bean><br>第三种：使用 mapper 扫描器：<br>（ 1 ） mapper.xml 文件编写：<br>mapper.xml 中的 namespace 为 mapper 接口的地址；<br>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一<br>致；<br>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在<br>sqlMapConfig.xml 中进行配置。<br>（ 2 ） 定义 mapper 接口：<br>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目<br>录<br>（ 3 ） 配置 mapper 扫描器：<br><bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"><br>&lt;property name=”basePackage” value=”mapper 接口包地址</bean></p><p>“&gt;<br><property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"><br><br>（ 4 ） 使用扫描器后从 spring 容器中获取 mapper 的实现对象。</property></p><h2 id="27-、简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><a href="#27-、简述-Mybatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="27 、简述 Mybatis 的插件运行原理，以及如何编写一个插件。"></a>27 、简述 Mybatis 的插件运行原理，以及如何编写一个插件。</h2><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC多线程及高并发</title>
      <link href="/2021/11/25/juc-duo-xian-cheng-ji-gao-bing-fa/"/>
      <url>/2021/11/25/juc-duo-xian-cheng-ji-gao-bing-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="JUC多线程及高并发"><a href="#JUC多线程及高并发" class="headerlink" title="JUC多线程及高并发"></a>JUC多线程及高并发</h2><p>[TOC]</p><h3 id="一、请你谈谈对volatile的理解"><a href="#一、请你谈谈对volatile的理解" class="headerlink" title="一、请你谈谈对volatile的理解"></a>一、请你谈谈对volatile的理解</h3><p>​    <code>Package java.util.concurrent</code>—&gt; <code>AtomicInteger</code>  <code>Lock</code> <code>ReadWriteLock</code></p><h4 id="1、volatile是java虚拟机提供的轻量级的同步机制"><a href="#1、volatile是java虚拟机提供的轻量级的同步机制" class="headerlink" title="1、volatile是java虚拟机提供的轻量级的同步机制"></a>1、volatile是java虚拟机提供的轻量级的同步机制</h4><p>保证可见性、不保证原子性、禁止指令重排</p><ol><li><p>保证可见性</p><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值</p><p>当不添加volatile关键字时示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 1验证volatile的可见性 * 1.1 如果int num = 0，number变量没有添加volatile关键字修饰 * 1.2 添加了volatile，可以解决可见性 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">visibilityByVolatile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//验证volatile的可见性</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">visibilityByVolatile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyData myData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//第一个线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t come in"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//线程暂停3s</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                myData<span class="token punctuation">.</span><span class="token function">addToSixty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t update value:"</span> <span class="token operator">+</span> myData<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"thread1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//第二个线程是main线程</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>myData<span class="token punctuation">.</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果myData的num一直为零，main线程一直在这里循环</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t mission is over, num value is "</span> <span class="token operator">+</span> myData<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyData</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//    int num = 0;</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addToSixty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">thread1     come inthread1     update value<span class="token operator">:</span><span class="token number">60</span><span class="token comment" spellcheck="true">//线程进入死循环</span></code></pre><p>当我们加上<code>volatile</code>关键字后，<code>volatile int num = 0;</code>输出结果为：</p><pre class=" language-java"><code class="language-java">thread1     come inthread1     update value<span class="token operator">:</span><span class="token number">60</span>main     mission is over<span class="token punctuation">,</span> num value is <span class="token number">60</span><span class="token comment" spellcheck="true">//程序没有死循环，结束执行</span></code></pre></li><li><p>==不保证原子性==</p><p>原子性：不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败</p><p>验证示例（变量添加volatile关键字，方法不添加synchronized）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 1验证volatile的可见性 *  1.1 如果int num = 0，number变量没有添加volatile关键字修饰 * 1.2 添加了volatile，可以解决可见性 * * 2.验证volatile不保证原子性 *  2.1 原子性指的是什么 *      不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        visibilityByVolatile();//验证volatile的可见性</span>        <span class="token function">atomicByVolatile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//验证volatile不保证原子性</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**     * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改     */</span>    <span class="token comment" spellcheck="true">//public static void visibilityByVolatile(){}</span>        <span class="token comment" spellcheck="true">/**     * volatile不保证原子性     * 以及使用Atomic保证原子性     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">atomicByVolatile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        MyData myData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    myData<span class="token punctuation">.</span><span class="token function">addSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    myData<span class="token punctuation">.</span><span class="token function">atomicAddSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"Thread "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//等待上面的线程都计算完成后，再用main线程取得最终结果值</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t finally num value is "</span><span class="token operator">+</span>myData<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t finally atomicnum value is "</span><span class="token operator">+</span>myData<span class="token punctuation">.</span>atomicInteger<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyData</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//    int num = 0;</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addToSixty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">atomicAddSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        atomicInteger<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行三次结果为：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.</span>main     <span class="token keyword">finally</span> num value is <span class="token number">19580</span>    main     <span class="token keyword">finally</span> atomicnum value is <span class="token number">20000</span><span class="token comment" spellcheck="true">//2.</span>main     <span class="token keyword">finally</span> num value is <span class="token number">19999</span>main     <span class="token keyword">finally</span> atomicnum value is <span class="token number">20000</span><span class="token comment" spellcheck="true">//3.</span>main     <span class="token keyword">finally</span> num value is <span class="token number">18375</span>main     <span class="token keyword">finally</span> atomicnum value is <span class="token number">20000</span><span class="token comment" spellcheck="true">//num并没有达到20000</span></code></pre></li><li><p>禁止指令重排</p><p>有序性：在计算机执行程序时，为了提高性能，编译器和处理器常常会对**==指令做重拍==**，一般分以下三种</p><pre class=" language-mermaid"><code class="language-mermaid">graph LR    源代码 --> id1["编译器优化的重排"]    id1 --> id2[指令并行的重排]    id2 --> id3[内存系统的重排]    id3 --> 最终执行的指令    style id1 fill:#ff8000;    style id2 fill:#fab400;    style id3 fill:#ffd557;</code></pre><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。</p><p>处理器在进行重排顺序是必须要考虑指令之间的**==数据依赖性==**</p><p>==多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性时无法确定的，结果无法预测==</p><p>重排代码实例：</p><p>声明变量：<code>int a,b,x,y=0</code></p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>结          果</td><td>x = 0      y=0</td></tr></tbody></table><p>如果编译器对这段程序代码执行重排优化后，可能出现如下情况：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x= a;</td><td>y = b;</td></tr><tr><td>结          果</td><td>x = 2      y=1</td></tr></tbody></table><p>这个结果说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的</p><p>volatile实现禁止指令重排，从而避免了多线程环境下程序出现乱序执行的现象</p><p>**==内存屏障==**（Memory Barrier）又称内存栅栏，是一个CPU指令，他的作用有两个：</p><ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li></ol><p>由于编译器和处理器都能执行指令重排优化。如果在之零件插入一i奥Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排顺序，也就是说==通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化==。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><pre class=" language-mermaid"><code class="language-mermaid">graph TB    subgraph     bbbb["对Volatile变量进行读操作时，<br>回在读操作之前加入一条load屏障指令，<br>从内存中读取共享变量"]    ids6[Volatile]-->red3[LoadLoad屏障]    red3-->id7["禁止下边所有普通读操作<br>和上面的volatile读重排序"]    red3-->red4[LoadStore屏障]    red4-->id9["禁止下边所有普通写操作<br>和上面的volatile读重排序"]    red4-->id8[普通读]    id8-->普通写    end    subgraph     aaaa["对Volatile变量进行写操作时，<br>回在写操作后加入一条store屏障指令，<br>将工作内存中的共享变量值刷新回到主内存"]    id1[普通读]-->id2[普通写]    id2-->red1[StoreStore屏障]    red1-->id3["禁止上面的普通写和<br>下面的volatile写重排序"]    red1-->id4["Volatile写"]    id4-->red2[StoreLoad屏障]    red2-->id5["防止上面的volatile写和<br>下面可能有的volatile读写重排序"]    end    style red1 fill:#ff0000;    style red2 fill:#ff0000;    style red4 fill:#ff0000;    style red3 fill:#ff0000;    style aaaa fill:#ffff00;    style bbbb fill:#ffff00;</code></pre></li></ol><h4 id="2、JMM（java内存模型）"><a href="#2、JMM（java内存模型）" class="headerlink" title="2、JMM（java内存模型）"></a>2、JMM（java内存模型）</h4><p>JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，他描述的时一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p><strong>JMM关于同步的规定：</strong></p><ol><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁时同一把锁</li></ol><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有的成为栈空间），工作内存是每个线程的私有数据区域，而java内存模型中规定所有变量都存储在**==主内存==<strong>，主内存是贡献内存区域，所有线程都可以访问，</strong>==但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先概要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，==<strong>不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存的</strong>==变量副本拷贝==**，因此不同的线程件无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，期间要访问过程如下图：<img src="https://s3.bmp.ovh/imgs/2021/11/c0e21f9b6d063613.jpg"></p><ol><li>可见性</li><li>原子性</li><li>有序性</li></ol><h4 id="3、你在那些地方用过volatile"><a href="#3、你在那些地方用过volatile" class="headerlink" title="3、你在那些地方用过volatile"></a>3、你在那些地方用过volatile</h4><p>当普通单例模式在多线程情况下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonDemo instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingletonDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 构造方法SingletonDemo（）"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//构造方法只会被执行一次</span><span class="token comment" spellcheck="true">//        System.out.println(getInstance() == getInstance());</span><span class="token comment" spellcheck="true">//        System.out.println(getInstance() == getInstance());</span><span class="token comment" spellcheck="true">//        System.out.println(getInstance() == getInstance());</span>        <span class="token comment" spellcheck="true">//并发多线程后，构造方法会在一些情况下执行多次</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                SingletonDemo<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其构造方法在一些情况下会被执行多次</p><p>解决方式：</p><ol><li><p><strong>单例模式DCL代码</strong></p><p>DCL （Double Check Lock双端检锁机制）在加锁前和加锁后都进行一次判断</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonDemo <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>大部分运行结果构造方法只会被执行一次</strong>，但指令重排机制会让程序很小的几率出现构造方法被执行多次</p><p>**==DCL（双端检锁）机制不一定线程安全==**，原因时有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象可能==没有完成初始化==。instance=new SingleDemo();可以被分为一下三步（伪代码）：</p><pre class=" language-java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1.分配对象内存空间</span><span class="token function">instance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2.初始化对象</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.设置instance执行刚分配的内存地址，此时instance!=null</span></code></pre><p>步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的，<strong>如果3步骤提前于步骤2，但是instance还没有初始化完成</strong></p><p>但是指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。</p><p>==所以当一条线程访问instance不为null时，由于instance示例未必已初始化完成，也就造成了线程安全问题。==</p></li><li><p><strong>单例模式volatile代码</strong></p><p>为解决以上问题，可以将SingletongDemo实例上加上volatile</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonDemo instance <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li></ol><h3 id="二、CAS你知道吗"><a href="#二、CAS你知道吗" class="headerlink" title="二、CAS你知道吗"></a>二、CAS你知道吗</h3><h4 id="1、compareAndSet—-比较并交换"><a href="#1、compareAndSet—-比较并交换" class="headerlink" title="1、compareAndSet—-比较并交换"></a>1、compareAndSet—-比较并交换</h4><p>AtomicInteger.conpareAndSet(int expect, indt update)</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>第一个参数为拿到的期望值，如果期望值没有一致，进行update赋值，如果期望值不一致，证明数据被修改过，返回fasle，取消赋值</p><p>例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>cas<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 1.CAS是什么？ * 1.1比较并交换 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CASDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">checkCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">checkCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t current data is "</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2014</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t current data is "</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果为：</p><pre class=" language-java"><code class="language-java"><span class="token boolean">true</span>     current data is <span class="token number">2019</span><span class="token boolean">false</span>     current data is <span class="token number">2019</span></code></pre><h4 id="2、CAS底层原理？对Unsafe的理解"><a href="#2、CAS底层原理？对Unsafe的理解" class="headerlink" title="2、CAS底层原理？对Unsafe的理解"></a>2、CAS底层原理？对Unsafe的理解</h4><p>比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较知道主内存和工作内存中的值一直为止</p><ol><li><p>atomicInteger.getAndIncrement();</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>Unsafe</p><ul><li><p>是CAS核心类，由于Java方法无法直接访问地层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存数据。Unsafe类存在于<code>sun.misc</code>包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p><p><strong>Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong></p></li><li><p>变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存便宜地址获取数据的</p></li><li><p>变量value用volatile修饰，保证多线程之间的可见性</p></li></ul></li><li><p>CAS是什么</p><p>CAS全称呼Compare-And-Swap，它是一条CPU并发原语</p><p>他的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p><p>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。这是一种完全依赖于硬件的功能，通过他实现了原子操作。由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//unsafe.getAndAddInt</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> var5<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> var5<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>var1 AtomicInteger对象本身</p><p>var2 该对象的引用地址</p><p>var4 需要变动的数据</p><p>var5 通过var1 var2找出的主内存中真实的值</p><p>用该对象前的值与var5比较；</p><p>如果相同，更新var5+var4并且返回true，</p><p>如果不同，继续去之然后再比较，直到更新完成</p></li></ol><h4 id="3、CAS缺点"><a href="#3、CAS缺点" class="headerlink" title="3、CAS缺点"></a>3、CAS缺点</h4><ol><li><p>** 循环时间长，开销大**</p><p>例如getAndAddInt方法执行，有个do while循环，如果CAS失败，一直会进行尝试，如果CAS长时间不成功，可能会给CPU带来很大的开销</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性</p></li><li><p><strong>ABA问题</strong></p></li></ol><h3 id="三、原子类AtomicInteger的ABA问题？原子更新引用？"><a href="#三、原子类AtomicInteger的ABA问题？原子更新引用？" class="headerlink" title="三、原子类AtomicInteger的ABA问题？原子更新引用？"></a>三、原子类AtomicInteger的ABA问题？原子更新引用？</h3><h4 id="1、ABA如何产生"><a href="#1、ABA如何产生" class="headerlink" title="1、ABA如何产生"></a>1、ABA如何产生</h4><p>CAS算法实现一个重要前提需要去除内存中某个时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如<strong>线程1</strong>从内存位置V取出A，<strong>线程2</strong>同时也从内存取出A，并且线程2进行一些操作将值改为B，然后线程2又将V位置数据改成A，这时候线程1进行CAS操作发现内存中的值依然时A，然后线程1操作成功。</p><p>==尽管线程1的CAS操作成功，但是不代表这个过程没有问题==</p><h4 id="2、如何解决？原子引用"><a href="#2、如何解决？原子引用" class="headerlink" title="2、如何解决？原子引用"></a>2、如何解决？原子引用</h4><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> juc<span class="token punctuation">.</span>cas<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>AllArgsConstructor<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Getter<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>ToString<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicRefrenceDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User z3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User l4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AtomicReference<span class="token operator">&lt;</span>User<span class="token operator">></span> atomicReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        atomicReference<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>z3<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>z3<span class="token punctuation">,</span> l4<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> atomicReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>z3<span class="token punctuation">,</span> l4<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> atomicReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@ToString</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    String userName<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果</p><pre class=" language-java"><code class="language-java"><span class="token boolean">true</span>    <span class="token function">User</span><span class="token punctuation">(</span>userName<span class="token operator">=</span>李四<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token boolean">false</span>    <span class="token function">User</span><span class="token punctuation">(</span>userName<span class="token operator">=</span>李四<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span></code></pre><h4 id="3、时间戳的原子引用"><a href="#3、时间戳的原子引用" class="headerlink" title="3、时间戳的原子引用"></a>3、时间戳的原子引用</h4><p>新增机制，修改版本号</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>cas<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicStampedReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * ABA问题解决 * AtomicStampedReference */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ABADemo</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> AtomicReference<span class="token operator">&lt;</span>Integer<span class="token operator">></span> atomicReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> AtomicStampedReference<span class="token operator">&lt;</span>Integer<span class="token operator">></span> atomicStampedReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====以下时ABA问题的产生====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//保证线程1完成一次ABA操作</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> atomicReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====以下时ABA问题的解决====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> stamp <span class="token operator">=</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t第1次版本号"</span> <span class="token operator">+</span> stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            atomicStampedReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t第2次版本号"</span> <span class="token operator">+</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            atomicStampedReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t第3次版本号"</span> <span class="token operator">+</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> stamp <span class="token operator">=</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t第1次版本号"</span> <span class="token operator">+</span> stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">boolean</span> result <span class="token operator">=</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">,</span> stamp<span class="token punctuation">,</span> stamp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t修改是否成功"</span> <span class="token operator">+</span> result <span class="token operator">+</span> <span class="token string">"\t当前最新实际版本号："</span> <span class="token operator">+</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t当前最新实际值："</span> <span class="token operator">+</span> atomicStampedReference<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 4"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>以下时ABA问题的产生<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token boolean">true</span>    <span class="token number">2019</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>以下时ABA问题的解决<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Thread <span class="token number">3</span>    第<span class="token number">1</span>次版本号<span class="token number">1</span>Thread <span class="token number">4</span>    第<span class="token number">1</span>次版本号<span class="token number">1</span>Thread <span class="token number">3</span>    第<span class="token number">2</span>次版本号<span class="token number">2</span>Thread <span class="token number">3</span>    第<span class="token number">3</span>次版本号<span class="token number">3</span>Thread <span class="token number">4</span>    修改是否成功<span class="token boolean">false</span>    当前最新实际版本号：<span class="token number">3</span>Thread <span class="token number">4</span>    当前最新实际值：<span class="token number">100</span></code></pre><h3 id="四、我们知道ArrayList是线程不安全的，请编写一个不安全的案例并给出解决方案"><a href="#四、我们知道ArrayList是线程不安全的，请编写一个不安全的案例并给出解决方案" class="headerlink" title="四、我们知道ArrayList是线程不安全的，请编写一个不安全的案例并给出解决方案"></a>四、我们知道ArrayList是线程不安全的，请编写一个不安全的案例并给出解决方案</h3><p>HashSet与ArrayList一致 HashMap</p><p>HashSet底层是一个HashMap，存储的值放在HashMap的key里，value存储了一个PRESENT的静态Object对象</p><h4 id="1、线程不安全"><a href="#1、线程不安全" class="headerlink" title="1、线程不安全"></a>1、线程不安全</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>collection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>UUID<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 集合类不安全问题 * ArrayList */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ContainerNotSafeDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">notSafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 故障现象     * java.util.ConcurrentModificationException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">notSafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>报错：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"Thread 10"</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConcurrentModificationException</code></pre><h4 id="2、导致原因"><a href="#2、导致原因" class="headerlink" title="2、导致原因"></a>2、导致原因</h4><p>并发正常修改导致</p><p>一个人正在写入，另一个同学来抢夺，导致数据不一致，并发修改异常</p><h4 id="3、解决方法：-CopyOnWriteArrayList"><a href="#3、解决方法：-CopyOnWriteArrayList" class="headerlink" title="3、解决方法：**CopyOnWriteArrayList"></a>3、解决方法：**CopyOnWriteArrayList</h4><pre><code>List&lt;String&gt; list = new Vector&lt;&gt;();//Vector线程安全List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());//使用辅助类List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();//写时复制，读写分离Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre><p>CopyOnWriteArrayList.add方法：</p><p>CopyOnWrite容器即写时复制，往一个元素添加容器的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，让后新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器setArray(newElements),这样做可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="五、公平锁、非公平锁、可重入锁、递归锁、自旋锁？手写自旋锁"><a href="#五、公平锁、非公平锁、可重入锁、递归锁、自旋锁？手写自旋锁" class="headerlink" title="五、公平锁、非公平锁、可重入锁、递归锁、自旋锁？手写自旋锁"></a>五、公平锁、非公平锁、可重入锁、递归锁、自旋锁？手写自旋锁</h3><h4 id="1、公平锁、非公平锁"><a href="#1、公平锁、非公平锁" class="headerlink" title="1、公平锁、非公平锁"></a>1、公平锁、非公平锁</h4><ol><li><p><strong>是什么</strong></p><p>公平锁就是先来后到、非公平锁就是允许加塞，<code>Lock lock = new ReentrantLock(Boolean fair);</code> 默认非公平。</p><ul><li><p>**==公平锁==**是指多个线程按照申请锁的顺序来获取锁，类似排队打饭。</p></li><li><p>**==非公平锁==**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者节现象。</p></li></ul></li><li><p><strong>两者区别</strong></p><ul><li><p><strong>公平锁</strong>：Threads acquire  a fair lock in the order in which they requested it</p><p>公平锁，就是很公平，在并发环境中，每个线程在获取锁时，会先查看此锁维护的等待队列，如果为空，或者当前线程就是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</p></li><li><p><strong>非公平锁</strong>：a nonfair lock permits barging: threads requesting a lock can jump ahead of the queue of waiting threads if the lock happens to be available when it is requested.</p><p>非公平锁比较粗鲁，上来就直接尝试占有额，如果尝试失败，就再采用类似公平锁那种方式。</p></li></ul></li><li><p><strong>other</strong></p><p>对Java ReentrantLock而言，通过构造函数指定该锁是否公平，磨粉是非公平锁，非公平锁的优点在于吞吐量比公平锁大</p><p>对Synchronized而言，是一种非公平锁</p></li></ol><h4 id="2、可重入所（递归锁）"><a href="#2、可重入所（递归锁）" class="headerlink" title="2、可重入所（递归锁）"></a>2、可重入所（递归锁）</h4><ol><li><p><strong>递归锁是什么</strong></p><p>指的时同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，==线程可以进入任何一个它已经拥有的锁所同步着的代码块==</p></li><li><p><strong>ReentrantLock/Synchronized 就是一个典型的可重入锁</strong></p></li><li><p><strong>可重入锁最大的作用是避免死锁</strong></p></li><li><p><strong>代码示例</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>lock<span class="token punctuation">;</span>####    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Phone phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                phone<span class="token punctuation">.</span><span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                phone<span class="token punctuation">.</span><span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sendSMS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t -----invoked sendSMS()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t +++++invoked sendEmail()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mobile mobile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mobile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mobile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Mobile</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t invoked get()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t invoked set()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="3、独占锁-写锁-共享锁-读锁-互斥锁"><a href="#3、独占锁-写锁-共享锁-读锁-互斥锁" class="headerlink" title="3、独占锁(写锁)/共享锁(读锁)/互斥锁"></a>3、独占锁(写锁)/共享锁(读锁)/互斥锁</h4><ol><li><p><strong>概念</strong></p><ul><li><p><strong>独占锁</strong>：指该锁一次只能被一个线程所持有，对ReentrantLock和Synchronized而言都是独占锁</p></li><li><p><strong>共享锁</strong>：只该锁可被多个线程所持有</p><p><strong>ReentrantReadWriteLock</strong>其读锁是共享锁，写锁是独占锁</p></li><li><p><strong>互斥锁</strong>：读锁的共享锁可以保证并发读是非常高效的，读写、写读、写写的过程是互斥的</p></li></ul></li><li><p><strong>代码示例</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantReadWriteLock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。 * 但是 * 如果有一个线程象取写共享资源来，就不应该自由其他线程可以对资源进行读或写 * 总结 * 读读能共存 * 读写不能共存 * 写写不能共存 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadWriteLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyCache myCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tempInt <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">,</span> tempInt <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tempInt <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ReentrantReadWriteLock rwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 写操作：原子+独占     * 整个过程必须是一个完整的统一体，中间不许被分割，不许被打断     *     * @param key     * @param value     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t正在写入："</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t写入完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t正在读取："</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object result <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t读取完成: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4、自旋锁"><a href="#4、自旋锁" class="headerlink" title="4、自旋锁"></a>4、自旋锁</h4><ol><li><p><strong>spinlock</strong></p><p>是指尝试获取锁的线程不会立即阻塞，而是==采用循环的方式去尝试获取锁==，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> var5<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> var5<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>手写自旋锁：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 实现自旋锁 * 自旋锁好处，循环比较获取知道成功位置，没有类似wait的阻塞 * * 通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，知道A释放锁后B随后抢到 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpinLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpinLockDemo spinLockDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpinLockDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">mylock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">mylock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//原子引用线程</span>    AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> atomicReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mylock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t come in"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t invoked myunlock()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="六、CountDownLatch-CyclicBarrier-Semaphore使用过吗"><a href="#六、CountDownLatch-CyclicBarrier-Semaphore使用过吗" class="headerlink" title="六、CountDownLatch/CyclicBarrier/Semaphore使用过吗"></a>六、CountDownLatch/CyclicBarrier/Semaphore使用过吗</h3><h4 id="1、CountDownLatch（火箭发射倒计时）"><a href="#1、CountDownLatch（火箭发射倒计时）" class="headerlink" title="1、CountDownLatch（火箭发射倒计时）"></a>1、CountDownLatch（火箭发射倒计时）</h4><ol><li><p>它允许一个或多个线程一直等待，知道其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行</p></li><li><p>CountDownLatch主要有两个方法，当一个或多个线程调用await()方法时，调用线程会被阻塞。其他线程调用countDown()方法会将计数器减1，当计数器的值变为0时，因调用await()方法被阻塞的线程才会被唤醒，继续执行</p></li><li><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>conditionThread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        general();</span>        <span class="token function">countDownLatchTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">general</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t上完自习，离开教室"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread-->"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t=====班长最后关门走人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countDownLatchTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t被灭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> CountryEnum<span class="token punctuation">.</span><span class="token function">forEach_CountryEnum</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRetMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t=====秦统一"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2、CyclicBarrier（集齐七颗龙珠召唤神龙）"><a href="#2、CyclicBarrier（集齐七颗龙珠召唤神龙）" class="headerlink" title="2、CyclicBarrier（集齐七颗龙珠召唤神龙）"></a>2、CyclicBarrier（集齐七颗龙珠召唤神龙）</h4><ol><li><p>CycliBarrier</p><p>可循环（Cyclic）使用的屏障。让一组线程到达一个屏障（也可叫同步点）时被阻塞，知道最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CycliBarrier的await()方法</p></li><li><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>conditionThread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BrokenBarrierException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CyclicBarrier<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">cyclicBarrierTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cyclicBarrierTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"====召唤神龙====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t收集到第"</span> <span class="token operator">+</span> tempInt <span class="token operator">+</span> <span class="token string">"颗龙珠"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="3、Semaphore信号量"><a href="#3、Semaphore信号量" class="headerlink" title="3、Semaphore信号量"></a>3、Semaphore信号量</h4><p>可以代替Synchronize和Lock</p><ol><li><p><strong>信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制</strong></p></li><li><p>代码示例：</p><p><strong>抢车位示例</strong>：</p><pre><code>package com.jian8.juc.conditionThread;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaphoreDemo {    public static void main(String[] args) {        Semaphore semaphore = new Semaphore(3);//模拟三个停车位        for (int i = 1; i &lt;= 6; i++) {//模拟6部汽车            new Thread(() -&gt; {                try {                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + "\t抢到车位");                    try {                        TimeUnit.SECONDS.sleep(3);//停车3s                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + "\t停车3s后离开车位");                } catch (InterruptedException e) {                    e.printStackTrace();                } finally {                    semaphore.release();                }            }, "Car " + i).start();        }    }}</code></pre></li></ol><h3 id="七、阻塞队列"><a href="#七、阻塞队列" class="headerlink" title="七、阻塞队列"></a>七、阻塞队列</h3><ul><li>**==ArrayBlockingQueue==**是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序</li><li>**==LinkedBlockingQueue==**是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue</li><li>**==SynchronousQueue==**是一个不存储元素的阻塞队列，灭个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于</li></ul><h4 id="1、队列和阻塞队列"><a href="#1、队列和阻塞队列" class="headerlink" title="1、队列和阻塞队列"></a>1、队列和阻塞队列</h4><ol><li><p>首先是一个队列，而一个阻塞队列再数据结构中所起的作用大致如下图</p><pre class=" language-mermaid"><code class="language-mermaid">graph LRThread1-- put -->id1["阻塞队列"]subgraph BlockingQueue    id1endid1-- Take -->Thread2蛋糕师父--"放(柜满阻塞)"-->id2[蛋糕展示柜]subgraph 柜    id2endid2--"取(柜空阻塞)"-->顾客</code></pre><p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p><p>当阻塞队列是空是，从队列中==获取==元素的操作会被阻塞</p><p>当阻塞队列是满时，从队列中==添加==元素的操作会被阻塞</p><p>试图从空的阻塞队列中获取元素的线程将会被阻塞，知道其他的线程网空的队列插入新的元素。</p><p>试图网已满的阻塞队列中添加新元素的线程同样会被阻塞，知道其他的线程从列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增</p></li></ol><h4 id="2、为什么用？有什么好处？"><a href="#2、为什么用？有什么好处？" class="headerlink" title="2、为什么用？有什么好处？"></a>2、为什么用？有什么好处？</h4><ol><li><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程，一旦满足条件，被挂起的线程又会自动被唤醒</p></li><li><p>为什么需要BlockingQueue</p><p>好处时我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，==我们每个程序员都必须自己控制这些细节，尤其还要兼顾效率和线程安全==，而这回给我们程序带来不小的复杂度</p></li></ol><h4 id="3、BlockingQueue的核心方法"><a href="#3、BlockingQueue的核心方法" class="headerlink" title="3、BlockingQueue的核心方法"></a>3、BlockingQueue的核心方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><table><thead><tr><th>方法类型</th><th>status</th></tr></thead><tbody><tr><td>抛出异常</td><td>当阻塞队列满时，再往队列中add会抛<code>IllegalStateException: Queue full</code><br>当阻塞队列空时，在网队列里remove会抛<code>NoSuchElementException</code></td></tr><tr><td>特殊值</td><td>插入方法，成功true失败false<br>移除方法，成功返回出队列的元素，队列里没有就返回null</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞线程知道put数据或响应中断退出<br>当阻塞队列空时，消费者线程试图从队列take元素，队列会一直阻塞消费者线程知道队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h4 id="4、架构梳理-种类分析"><a href="#4、架构梳理-种类分析" class="headerlink" title="4、架构梳理+种类分析"></a>4、架构梳理+种类分析</h4><ol><li><p>种类分析</p><ul><li>==ArrayBlockingQueue==:由数据结构组成的有界阻塞队列。</li><li>==LinkedBlockingQueue==:由链表结构组成的有界（但大小默认值为<code>Integer.MAX_VALUE</code>)阻塞队列。</li><li>PriorityBlockingQueue:支持优先级排序的无界阻塞队列。</li><li>DelayQueue:使用优先级队列实现的延迟无界阻塞队列。</li><li>==SychronousQueue==:不存储元素的阻塞队列，也即单个元素的队列。</li><li>LinkedTransferQueue:由链表结构组成的无界阻塞队列。</li><li>LinkedBlocking<strong>Deque</strong>:由历览表结构组成的双向阻塞队列。</li></ul></li><li><p><strong>SychronousQueue</strong></p><ul><li><p>理论：SynchronousQueue没有容量，与其他BlockingQueue不同，SychronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。</p></li><li><p>代码示例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>queue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序 * LinkedBlockingQueue是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue * SynchronousQueue是一个不存储元素的阻塞队列，灭个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 * 1.队列 * 2.阻塞队列 * 2.1 阻塞队列有没有好的一面 * 2.2 不得不阻塞，你如何管理 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronousQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t put 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t put 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t put 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\ttake "</span> <span class="token operator">+</span> blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\ttake "</span> <span class="token operator">+</span> blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\ttake "</span> <span class="token operator">+</span> blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"BBB"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li></ol><h4 id="5、用在哪里"><a href="#5、用在哪里" class="headerlink" title="5、用在哪里"></a>5、用在哪里</h4><ol><li><p>生产者消费者模式</p><ul><li><p>传统版</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>queue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Condition<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 一个初始值为零的变量，两个线程对其交替操作，一个加1一个减1，来5轮 * 1. 线程  操作  资源类 * 2. 判断  干活  通知 * 3. 防止虚假唤起机制 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProdConsumer_TraditionDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ShareData shareData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    shareData<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"ProductorA "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    shareData<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"ConsumerA  "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    shareData<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"ProductorB "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    shareData<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"ConsumerB  "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ShareData</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//资源类</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//1.判断</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//等待不能生产</span>                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//2.干活</span>            number<span class="token operator">++</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//3.通知</span>            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//1.判断</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//等待不能消费</span>                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//2.消费</span>            number<span class="token operator">--</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//3.通知</span>            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>阻塞队列版</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>queue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProdConsumer_BlockQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyResource myResource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyResource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t生产线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                myResource<span class="token punctuation">.</span><span class="token function">myProd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Prod"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t消费线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                myResource<span class="token punctuation">.</span><span class="token function">myConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Consumer"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5s后main叫停，线程结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            myResource<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyResource</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认开启，进行生产+消费</span>    <span class="token keyword">private</span> AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyResource</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>blockingQueue <span class="token operator">=</span> blockingQueue<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myProd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String data <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> retValue<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            data <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            retValue <span class="token operator">=</span> blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t插入队列"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t插入队列"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t大老板叫停了，flag=false，生产结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> result <span class="token operator">||</span> result<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t超过2s没有取到蛋糕，消费退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t消费队列"</span> <span class="token operator">+</span> result <span class="token operator">+</span> <span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>线程池</p></li><li><p>消息中间件</p></li></ol><h4 id="6、synchronized和lock有什么区别？用新的lock有什么好处？请举例"><a href="#6、synchronized和lock有什么区别？用新的lock有什么好处？请举例" class="headerlink" title="6、synchronized和lock有什么区别？用新的lock有什么好处？请举例"></a>6、synchronized和lock有什么区别？用新的lock有什么好处？请举例</h4><blockquote><p>区别</p></blockquote><ol><li><p>原始构成</p><ul><li><p>synchronized时关键字属于jvm</p><p><strong>monitorenter</strong>，底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步或方法中才能掉wait/notify等方法</p><p><strong>monitorexit</strong></p></li><li><p>Lock是具体类，是api层面的锁（java.util.）</p></li></ul></li><li><p>使用方法</p><ul><li>sychronized不需要用户取手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用</li><li>ReentrantLock则需要用户去手动释放锁若没有主动释放锁，就有可能导致出现死锁现象，需要lock()和unlock()方法配合try/finally语句块来完成</li></ul></li><li><p>等待是否可中断</p><ul><li>synchronized不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock可中断，设置超时方法tryLock(long timeout, TimeUnit unit)，或者lockInterruptibly()放代码块中，调用interrupt()方法可中断。</li></ul></li><li><p>加锁是否公平</p><ul><li>synchronized非公平锁</li><li>ReentrantLock两者都可以，默认公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁</li></ul></li><li><p>锁绑定多个条件Condition</p><ul><li>synchronized没有</li><li>ReentrantLock用来实现分组唤醒需要要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Condition<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * synchronized和lock区别 * &lt;p===lock可绑定多个条件=== * 对线程之间按顺序调用，实现A>B>C三个线程启动，要求如下： * AA打印5次，BB打印10次，CC打印15次 * 紧接着 * AA打印5次，BB打印10次，CC打印15次 * 。。。。 * 来十轮 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncAndReentrantLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ShareData shareData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shareData<span class="token punctuation">.</span><span class="token function">print5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shareData<span class="token punctuation">.</span><span class="token function">print10</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shareData<span class="token punctuation">.</span><span class="token function">print15</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ShareData</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//A:1 B:2 C:3</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition condition1 <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition condition2 <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition condition3 <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                condition1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//干活</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//通知</span>            number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            condition2<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                condition2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//干活</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//通知</span>            number <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            condition3<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print15</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                condition3<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//干活</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//通知</span>            number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            condition1<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="八、线程池用过吗？ThreadPoolExecutor谈谈你的理解"><a href="#八、线程池用过吗？ThreadPoolExecutor谈谈你的理解" class="headerlink" title="八、线程池用过吗？ThreadPoolExecutor谈谈你的理解"></a>八、线程池用过吗？ThreadPoolExecutor谈谈你的理解</h3><h4 id="1、Callable接口的使用"><a href="#1、Callable接口的使用" class="headerlink" title="1、Callable接口的使用"></a>1、Callable接口的使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>FutureTask<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 多线程中，第三种获得多线程的方式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//FutureTask(Callable&lt;V> callable)</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">,</span> <span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        new Thread(futureTask, "BBB").start();//复用，直接取值，不要重启两个线程</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//b = futureTask.get();//要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致堵塞，直到计算完成</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>futureTask<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//当futureTask完成后取值</span>            b <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*******Result"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Callable come in"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2、为什么使用线程池"><a href="#2、为什么使用线程池" class="headerlink" title="2、为什么使用线程池"></a>2、为什么使用线程池</h4><ol><li><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动给这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行</p></li><li><p>主要特点</p><p>线程复用、控制最大并发数、管理线程</p><ul><li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提过响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li><li>提高线程的客观理想。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul></li></ol><h4 id="3、线程池如何使用"><a href="#3、线程池如何使用" class="headerlink" title="3、线程池如何使用"></a>3、线程池如何使用</h4><ol><li><p>架构说明</p><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor</p><pre class=" language-mermaid"><code class="language-mermaid">graph BT    类-Executors    类-ScheduledThreadPoolExecutor-->类-ThreadPoolExecutor    类-ThreadPoolExecutor-->类-AbstractExecutorService    类-AbstractExecutorService-.->接口-ExecutorService    类-ScheduledThreadPoolExecutor-.->接口-ScheduledExecutorService    接口-ScheduledExecutorService-->接口-ExecutorService    接口-ExecutorService-->接口-Executor</code></pre></li><li><p>编码实现</p><p>实现有五种，Executors.newScheduledThreadPool()是带时间调度的，java8新推出Executors.newWorkStealingPool(int),使用目前机器上可用的处理器作为他的并行级别</p><p>重点有三种</p><ul><li><p>Executors.newFixedThreadPool(int) </p><p><strong>执行长期的任务，性能好很多</strong></p><p>创建一个定长线程池，可控制线程最大并发数，炒出的线程回在队列中等待。</p><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是想到等的，他使用的是LinkedBlockingQueue</p></li><li><p>Executors.newSingleThreadExecutor()</p><p><strong>一个任务一个任务执行的场景</strong></p><p>创建一个单线程话的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</p><p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue</p></li><li><p>Executors.newCachedThreadPool() </p><p><strong>执行很多短期异步的小程序或负载较轻的服务器</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲县城，若无可回收，则新建线程。</p><p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE,使用的SynchronousQueue,也就是说来了任务就创建线程运行，当县城空闲超过60s，就销毁线程</p></li></ul></li><li><p><strong>ThreadPoolExecutor</strong></p></li></ol><h4 id="4、线程池的几个重要参数介绍"><a href="#4、线程池的几个重要参数介绍" class="headerlink" title="4、线程池的几个重要参数介绍"></a>4、线程池的几个重要参数介绍</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</code></pre><ol><li>**==corePoolSize==**：线程池中常驻核心线程数<ul><li>在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务</li><li>当线程池的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中</li></ul></li><li>**==maximumPoolSize==**：线程池能够容纳同时执行的最大线程数，必须大于等于1</li><li>**==keepAliveTime==**：多余的空闲线程的存活时间<ul><li>当前线程池数量超过corePoolSize时，档口空闲时间达到keepAliveTime值时，多余空闲线程会被销毁到只剩下corePoolSize个线程为止</li></ul></li><li>**==unit==**：keepAliveTime的单位</li><li>**==workQueue==**：任务队列，被提交但尚未被执行的任务</li><li>**==threadFactory==**：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可</li><li>**==handler==**：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runable的策略</li></ol><h4 id="5、线程池的底层工作原理"><a href="#5、线程池的底层工作原理" class="headerlink" title="5、线程池的底层工作原理"></a>5、线程池的底层工作原理</h4><pre class=" language-mermaid"><code class="language-mermaid">graph LRsubgraph 使用者main(提交任务)endmain-->core{核心线程是否已满}subgraph 线程池core--是-->queue{队列是否已满}queue--是-->pool{线程池是否已满}pool--是-->reject["按照拒绝策略处理<br>无法执行的任务"]core--否-->id[创建线程执行任务]queue--否-->任务入队列等待pool--否-->创建线程执行任务end</code></pre><p><strong>==流程==</strong></p><ol><li><p>在创建了线程池之后，等待提交过来的 人物请求。</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p><p>2.1 如果正在运行的线程数量小于corePoolSize，那么马上船舰线程运行这个任务；</p><p>2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p><p>2.3如果此时队列满了且运行的线程数小于maximumPoolSize，那么还是要创建非核心线程立刻运行此任务</p><p>2.4如果队列满了且正在运行的线程数量大于或等于maxmumPoolSize，那么启动饱和拒绝策略来执行</p></li><li><p>当一个线程完成任务时，他会从队列中却下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：</p><p>如果当前运行的线程数大于corePoolSize，那么这个线程会被停掉；所以线程池的所有任务完成后他最大会收缩到corePoolSize的大小</p></li></ol><h3 id="九、线程池用过吗？生产上你如何设置合理参数"><a href="#九、线程池用过吗？生产上你如何设置合理参数" class="headerlink" title="九、线程池用过吗？生产上你如何设置合理参数"></a>九、线程池用过吗？生产上你如何设置合理参数</h3><h4 id="1、线程池的拒绝策略"><a href="#1、线程池的拒绝策略" class="headerlink" title="1、线程池的拒绝策略"></a>1、线程池的拒绝策略</h4><ol><li><p>什么是线程策略</p><p>等待队列也已经排满了，再也塞不下新任务了，同时线程池中的max线程也达到了，无法继续为新任务服务。这时我们就需要拒绝策略机制合理的处理这个问题。</p></li><li><p>JDK内置的拒绝策略</p><ul><li><p>AbortPolicy(默认)</p><p>直接抛出RejectedExecutionException异常阻止系统正常运行</p></li><li><p>CallerRunsPolicy</p><p>”调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</p></li><li><p>DiscardOldestPolicy</p><p>抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p></li><li><p>DiscardPolicy</p><p>直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案</p></li></ul></li><li><p>均实现了RejectedExecutionHandler接口</p></li></ol><h4 id="2、你在工作中单一的-固定数的-可变的三种创建线程池的方法，用哪个多"><a href="#2、你在工作中单一的-固定数的-可变的三种创建线程池的方法，用哪个多" class="headerlink" title="2、你在工作中单一的/固定数的/可变的三种创建线程池的方法，用哪个多"></a>2、你在工作中单一的/固定数的/可变的三种创建线程池的方法，用哪个多</h4><p><strong>==一个都不用，我们生产上只能使用自定义的！！！！==</strong></p><p>为什么？</p><p>线程池不允许使用Executors创建，试试通过ThreadPoolExecutor的方式，规避资源耗尽风险</p><p>FixedThreadPool和SingleThreadPool允许请求队列长度为Integer.MAX_VALUE，可能会堆积大量请求；；CachedThreadPool和ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量线程，导致OOM</p><h4 id="3、你在工作中时如何使用线程池的，是否自定义过线程池使用"><a href="#3、你在工作中时如何使用线程池的，是否自定义过线程池使用" class="headerlink" title="3、你在工作中时如何使用线程池的，是否自定义过线程池使用"></a>3、你在工作中时如何使用线程池的，是否自定义过线程池使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 第四种获得java多线程的方式--线程池 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 1L<span class="token punctuation">,</span>                                            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                            Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                             <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//new ThreadPoolExecutor.AbortPolicy();</span><span class="token comment" spellcheck="true">//new ThreadPoolExecutor.CallerRunsPolicy();</span><span class="token comment" spellcheck="true">//new ThreadPoolExecutor.DiscardOldestPolicy();</span><span class="token comment" spellcheck="true">//new ThreadPoolExecutor.DiscardPolicy();</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t办理业务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4、合理配置线程池你是如何考虑的？"><a href="#4、合理配置线程池你是如何考虑的？" class="headerlink" title="4、合理配置线程池你是如何考虑的？"></a>4、合理配置线程池你是如何考虑的？</h4><ol><li><p><strong>CPU密集型</strong></p><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务配置尽可能少的线程数量：</p><p>==<strong>一般公式：CPU核数+1个线程的线程池</strong>==</p></li><li><p><strong>IO密集型</strong></p><ul><li><p>由于IO密集型任务线程并不是一直在执行任务，则应配置经可能多的线程，如CPU核数 * 2</p></li><li><p>IO密集型，即该任务需要大量的IO，即大量的阻塞。</p><p>在单线程上运行IO密集型的任务会导致浪费大量的 CPU运算能力浪费在等待。</p><p>所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集型时，大部分线程都阻塞，故需要多配置线程数：</p><p>参考公式：==CPU核数/（1-阻塞系数） 阻塞系数在0.8~0.9之间==</p><p>八核CPU：8/（1-0，9）=80</p></li></ul></li></ol><h3 id="十、死锁编码及定位分析"><a href="#十、死锁编码及定位分析" class="headerlink" title="十、死锁编码及定位分析"></a>十、死锁编码及定位分析</h3><ol><li><p>是什么</p><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><pre class=" language-mermaid"><code class="language-mermaid">graph TD threadA(线程A) threadB(线程B) lockA((锁A)) lockB((锁B)) threadA--持有-->lockA threadB--试图获取-->lockA threadB--持有-->lockB threadA--试图获取-->lockB</code></pre></li><li><p>产生死锁的主要原因</p><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul></li><li><p>死锁示例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jian8<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去， */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String lockA <span class="token operator">=</span> <span class="token string">"lockA"</span><span class="token punctuation">;</span>        String lockB <span class="token operator">=</span> <span class="token string">"lockB"</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HoldThread</span><span class="token punctuation">(</span>lockA<span class="token punctuation">,</span>lockB<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Thread-AAA"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HoldThread</span><span class="token punctuation">(</span>lockB<span class="token punctuation">,</span>lockA<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Thread-BBB"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">HoldThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockA<span class="token punctuation">;</span>    <span class="token keyword">private</span> String lockB<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HoldThread</span><span class="token punctuation">(</span>String lockA<span class="token punctuation">,</span> String lockB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockA <span class="token operator">=</span> lockA<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockB <span class="token operator">=</span> lockB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t自己持有："</span> <span class="token operator">+</span> lockA <span class="token operator">+</span> <span class="token string">"\t尝试获得："</span> <span class="token operator">+</span> lockB<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t自己持有："</span> <span class="token operator">+</span> lockB <span class="token operator">+</span> <span class="token string">"\t尝试获得："</span> <span class="token operator">+</span> lockA<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>解决</p><ol><li>使用<code>jps -l</code>定位进程号</li><li><code>jstack 进程号</code>找到死锁查看</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm笔记</title>
      <link href="/2021/11/25/jvm/"/>
      <url>/2021/11/25/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote><p>熟悉JVM架构与GC垃圾回收机制以及相应的堆参调优，有过在linux进行系统调优的经验</p></blockquote><h2 id="一、JVM组成结构谈谈"><a href="#一、JVM组成结构谈谈" class="headerlink" title="一、JVM组成结构谈谈"></a>一、JVM组成结构谈谈</h2><p><img src="https://s3.bmp.ovh/imgs/2021/11/ccdb8ed73481c084.jpg"></p><p>JVM是运行在操作系统之上的，他与硬件没有直接的交互。</p><h2 id="二、JVM体系结构概览"><a href="#二、JVM体系结构概览" class="headerlink" title="二、JVM体系结构概览"></a>二、JVM体系结构概览</h2><p><img src="https://s3.bmp.ovh/imgs/2021/11/c6e7c98542d505b7.jpg"></p><ol><li><p>Class Loader类加载器</p><p>负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，值与他是否可以允许，则由Execution Engine决定</p></li><li><p>Execution Engine执行引擎 负责解释命令，提交操作系统执行</p></li><li><p>Native Interface 本地接口</p><p>Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</p></li><li><p>Native Method Stack 本地方法栈</p><p>java在内存中专门开辟了一块区域处理标记为native的代码，他的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。</p></li><li><p>Runtime Data Area 运行数据区</p></li><li><p>Method Area方法区</p><p>方法去是被所有线程共享，所有字段和方法字节码、以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，==此区属于共享区间==。用来保存装载的类的元结构信息。</p><p>==静态变量+常量+类信息+运行时常量池存放在<strong>方法区</strong>==</p><p>==实例变量存在<strong>堆内存</strong>中==</p></li><li><p>PC Register 程序计数器</p><p>每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），有执行引擎读取下一条指令，是一个非常小的内存空间，可以忽略不记</p><p><strong>==栈管运行，堆管存储==</strong></p></li><li><p><strong>Java Stack 栈</strong></p><p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<strong>基本类型的变量、实例方法、引用类型变量都是在函数的栈内存中分配</strong></p></li></ol><blockquote><p><strong>栈管运行，堆管存储</strong></p></blockquote><h2 id="三、栈（Stak）"><a href="#三、栈（Stak）" class="headerlink" title="三、栈（Stak）"></a>三、栈（Stak）</h2><p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<strong>基本类型的变量、实例方法、引用类型变量都是在函数的栈内存中分配</strong></p><h3 id="3-1-栈存储什么"><a href="#3-1-栈存储什么" class="headerlink" title="3.1 栈存储什么"></a>3.1 栈存储什么</h3><p><strong>先进后出，后进先出即为栈</strong></p><p>栈帧中主要保存3类数据</p><ul><li>本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；</li><li>栈操作（Operand Stack）：记录出栈、入栈的操作；</li><li>栈帧数据（Frame Data）：包括类文件、方法等。</li></ul><h3 id="3-2-栈运行原理"><a href="#3-2-栈运行原理" class="headerlink" title="3.2 栈运行原理"></a>3.2 栈运行原理</h3><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存去块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，</p><p>当一个方法A被调用时就产生一个栈帧F1，并被压入到栈中，</p><p>A方法调用了B方法，于是产生栈帧F2也被压入到栈，</p><p>B方法调用了C方法，于是产生栈帧F3也被压入到栈。。。</p><p>执行完毕后，先弹出F3，再弹出F2，再弹出F1.。。。</p><p>遵循“先进后出/后进先出”的原则。</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/9138931386992c40.jpg"></p><p>图示在一个栈中有两个栈：</p><p>栈2是最先被调用的方法，先入栈，</p><p>然后方法2调用了方法1，栈帧1处于栈顶的位置，</p><p>栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，</p><p>线程结束，栈释放。</p><p><strong>每执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。</strong></p><h3 id="3-3-判断JVM优化是哪里"><a href="#3-3-判断JVM优化是哪里" class="headerlink" title="3.3 判断JVM优化是哪里"></a>3.3 判断JVM优化是哪里</h3><p>主要时优化堆</p><h3 id="3-4-三种JVM"><a href="#3-4-三种JVM" class="headerlink" title="3.4 三种JVM"></a>3.4 三种JVM</h3><ol><li>Sun公司的HotSpot</li><li>BEA公司的JRockit</li><li>IBM公司的 J9 VM</li></ol><h2 id="四、堆（Heap）"><a href="#四、堆（Heap）" class="headerlink" title="四、堆（Heap）"></a>四、堆（Heap）</h2><h3 id="4-1-堆内存示意图"><a href="#4-1-堆内存示意图" class="headerlink" title="4.1 堆内存示意图"></a>4.1 堆内存示意图</h3><p><img src="https://s3.bmp.ovh/imgs/2021/11/cc0e316bdf213133.jpg" alt="堆内存示意图"></p><h3 id="4-2-新生区"><a href="#4-2-新生区" class="headerlink" title="4.2 新生区"></a>4.2 新生区</h3><p>新生区是类的诞生、成长、消亡的区域，一个类再这里产生，应用，最后被垃圾回收器收集，结束生命。新生去又分欸两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是再伊甸区被new出来。幸存区又连个：0区和1区。当伊甸园的空间用完是，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园区中的生于对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。如果1区也满了，再移动到养老区。若养老区也满了，那么这时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了FullGC后发现依然无法进行对象保存，就会产生OOM异常（OutOfMemoryError）。</p><ul><li><p>如果出现<code>java.lang.OutOfMemoryError:Java heap space</code>异常，说明java虚拟机的堆内存不够。原因有二：</p><ol><li><p>Java虚拟机的对内存设置不够，可以通过参数-Xms、-Xmx来调整</p><p>默认最大内存是机器的四分之一大小</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p></li></ol></li></ul><p><strong>==JDK1.8之后，永久代取消了，由元空间取代==</strong></p><h3 id="4-3-养老区"><a href="#4-3-养老区" class="headerlink" title="4.3 养老区"></a>4.3 养老区</h3><p>养老区用于保存从新生区筛选出来的JAVA对象，一般池对象都在这个区域活跃。</p><h3 id="4-4-永久区"><a href="#4-4-永久区" class="headerlink" title="4.4 永久区"></a>4.4 永久区</h3><p>永久存储区是一个常驻内存区域，用于存放JDK滋生所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。</p><ul><li>如果出现<code>java.lang.OutOfMemoryError:PermGen space</code>，说明是Java虚拟机对永久带Perm内存设置不够，一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被沾满。<ul><li>Jdk1.6之前：有永久代，常量值1.6在方法区</li><li>Jdk1.7：有永久代，但已经逐步“去永久代”，常量池1.7在堆</li><li>Jdk1.8之后：无永久代，常量池1.8在元空间</li></ul></li></ul><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>逻辑上堆由新生代、养老代、元空间构成、实际上堆只有新生和养老代；方法区就是永久代，永久代是方法区的实现</p><ul><li>方法去（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的类信息、普通常量、静态常量、编译器编译后的代码等，虽然JVM规范将方法去描述为堆的一个逻辑部分，但他却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>对于HotSpot虚拟机，很多开发者习惯将方法区成为“永久代”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口Interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。</li><li>常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放</li></ul><h2 id="五、JVM垃圾收集（Java-Garbage-Collection）"><a href="#五、JVM垃圾收集（Java-Garbage-Collection）" class="headerlink" title="五、JVM垃圾收集（Java Garbage Collection）"></a>五、JVM垃圾收集（Java Garbage Collection）</h2><p><img src="https://s3.bmp.ovh/imgs/2021/11/8b42ecfaaf505f33.jpg"></p><p><img src="https://s3.bmp.ovh/imgs/2021/11/6dda84873a04963a.jpg"></p><h3 id="5-1-堆内存调优简介"><a href="#5-1-堆内存调优简介" class="headerlink" title="5.1 堆内存调优简介"></a>5.1 堆内存调优简介</h3><table><thead><tr><th>-Xms</th><th>设置初始分配大小，默认为物理内存的“1/64”</th></tr></thead><tbody><tr><td>-Xmx</td><td>最大分配内存，默认为物理内存的“1/4”</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC处理日志</td></tr></tbody></table><h2 id="六、GC三大算法"><a href="#六、GC三大算法" class="headerlink" title="六、GC三大算法"></a>六、GC三大算法</h2><h3 id="6-1-GC算法总体概述"><a href="#6-1-GC算法总体概述" class="headerlink" title="6.1 GC算法总体概述"></a>6.1 GC算法总体概述</h3><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。</p><p>因此GC按照回收的区域又分了两种类型，一种是普通GC（MinorGC），一种时全局GC（FullGC）</p><ul><li>普通GC：只针对新生代区域的GC</li><li>全局GC：针对年老代的GC，偶尔伴随对新生代的GC以及堆永久代的GC。</li></ul><h3 id="6-2-复制算法：MinorGC（普通GC"><a href="#6-2-复制算法：MinorGC（普通GC" class="headerlink" title="6.2 复制算法：MinorGC（普通GC)"></a>6.2 复制算法：MinorGC（普通GC)</h3><p>新生代使用的MinorGC，这种GC算法采用的是复制算法（Copying），频繁使用</p><p>复制–&gt;清空–&gt;互换</p><h4 id="6-2-1-原理"><a href="#6-2-1-原理" class="headerlink" title="6.2.1 原理"></a>6.2.1 原理</h4><p>MinorGC会把Eden中的所有或的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old Generation中，也即一旦收集后，Eden区就变成空的了。</p><p>当对象在Eden（包括一个Survivor区域，这里假设是from区域）出生后，在经过一次MinorGC后，如果对象还存活，并且能够被另外一块Survivor区域所容纳（上面已经假设为from区域，这里应为to区域，即to区域又足够的内存空间来存储Eden和from区域中存活的对象），则使用复制算法将这些仍然还存活的对象复制到另外一块Survivor区域（即to区）中，然后清理所有使用过的Eden以及Survivor区域（即from区），并且讲这些对象的年龄设置为1，以后对象在Survivor区没熬过一次MinorGC，就将对象的年龄+1，当对象的年龄达到某个值时（默认15，通过<code>-XX：MaxTenuringThreshold</code>来设定参数），这些对象就会成为老年代。</p><p>==-XX：MaxTenuringThreshold设置对象在新生代中存活的次数==</p><h4 id="6-2-2-解释"><a href="#6-2-2-解释" class="headerlink" title="6.2.2 解释"></a>6.2.2 解释</h4><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和两个Survivor区，默认比例是8:1:1，一般情况下，新创建的对象都会被分配到Eden区，这些对象经过第一次的MinorGC后，如果仍然存活，将会被移到Survivor区。对象Survivor区中每熬过一次MinorGC，年龄就增加一岁，当他的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死（80%以上），所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>==复制要交换，谁空谁是to==</p><h4 id="6-3-3-劣势"><a href="#6-3-3-劣势" class="headerlink" title="6.3.3 劣势"></a>6.3.3 劣势</h4><p>复制算法弥补了标记清除算法中，内存布局混乱的缺点。</p><ol><li>浪费了一般的内存，太要命了</li><li>如果对象的存活率很高，我们可以极端一点，假设是100%存活率，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度是，将会变的不可忽视。所以从以上描述不难看出，复制算法想要使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要客服50%的内存的浪费</li></ol><h3 id="6-3-标记清除-标记整理算法：FullGC又叫MajorGC（全局GC"><a href="#6-3-标记清除-标记整理算法：FullGC又叫MajorGC（全局GC" class="headerlink" title="6.3 标记清除/标记整理算法：FullGC又叫MajorGC（全局GC)"></a>6.3 标记清除/标记整理算法：FullGC又叫MajorGC（全局GC)</h3><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><h4 id="6-3-1-标记清除（Mark-Sweep"><a href="#6-3-1-标记清除（Mark-Sweep" class="headerlink" title="6.3.1 标记清除（Mark-Sweep)"></a>6.3.1 标记清除（Mark-Sweep)</h4><h5 id="6-3-1-1-原理"><a href="#6-3-1-1-原理" class="headerlink" title="6.3.1.1 原理"></a>6.3.1.1 原理</h5><ol><li><p>标记（mark）</p><p>从根集合开始扫描，对存活的对象进行标记</p></li><li><p>清除（Sweep）</p><p>扫描整个内存空间，回收未被标记的对象，使用free-list记录可以区域。</p></li></ol><h5 id="6-3-1-2-劣势"><a href="#6-3-1-2-劣势" class="headerlink" title="6.3.1.2 劣势"></a>6.3.1.2 劣势</h5><ol><li>效率低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲</li><li>清理出来的空闲内存不是连续的，我们的死亡对象都是随机的出现在内存的各个角落，限制把他们清除之后，内存的布局自然会乱七八糟，而为了应付这一点，JVM不得不维持一个内存的空闲列表，这又是一种开销，而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</li></ol><h4 id="6-3-2-标记整理（Mark-Compact"><a href="#6-3-2-标记整理（Mark-Compact" class="headerlink" title="6.3.2 标记整理（Mark-Compact)"></a>6.3.2 标记整理（Mark-Compact)</h4><h5 id="6-3-2-1-原理"><a href="#6-3-2-1-原理" class="headerlink" title="6.3.2.1 原理"></a>6.3.2.1 原理</h5><ol><li><p>标记</p><p>与标记-清除一样</p></li><li><p>压缩整理</p><p>再次扫描，并往一段滑动存活对象</p></li></ol><h5 id="6-3-2-2-劣势"><a href="#6-3-2-2-劣势" class="headerlink" title="6.3.2.2 劣势"></a>6.3.2.2 劣势</h5><p>效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上说，效率要低于复制算法</p><h3 id="6-4-小总结"><a href="#6-4-小总结" class="headerlink" title="6.4 小总结"></a>6.4 小总结</h3><ul><li><strong>内存效率</strong>：复制算法&gt;标记清除算法&gt;标记整理算法</li><li><strong>内存整齐度</strong>：复制算法=标记整理算法&gt;标记清除算法</li><li><strong>内存利用率</strong>：标记整理算法=标记清除算法&gt;复制算法</li></ul><p>分代收集算法</p><p>引用计数法：</p><ul><li>缺点：每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗</li><li>较难处理循环引用</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -jvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
